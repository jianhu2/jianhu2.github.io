<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>老胡的星辰随笔 | IDE</title>
    <meta name="description" content=" ">
    <link rel="canonical" href="https://hujian.xyz/tags/ide/" />
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <meta property="og:title" content="IDE" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://hujian.xyz/tags/ide/" />

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="IDE"/>
<meta name="twitter:description" content=""/>

    
        
    

    <link rel="stylesheet" href='/css/style.css' />
    <link rel="stylesheet" href='/css/search.css' />
    <link rel="stylesheet" href='/css/md_nb.css' />
    <link rel="stylesheet" href='/css/list.css' />
    <link rel="stylesheet" href='/css/terms.css' />
    <link rel="stylesheet" href='/css/taxonomy.css' />
    <link rel="stylesheet" href='/css/font-awesome-4.7.0/css/font-awesome.min.css' />
    <link rel="stylesheet" href='/css/home.css' />
    <link rel="stylesheet" href='/css/syntax.css' />
    
        <link rel="stylesheet" href='/css/comment.css' />
    
    <link rel="stylesheet" href='/css/shortcode.css' />
    
    
    <link rel="stylesheet" href='/css/_custom.css' />
    <style>
         
    </style>
    
    
        <script src='//cdnjs.cloudflare.com/ajax/libs/valine/1.5.0/Valine.min.js'></script>
    
    
    
    <script src="/js/lazysizes.min.js" async=""></script>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/search.js"></script>
    <script src="/js/md_nb.js"></script>
    <script src="/js/yes.js"></script>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</head><body style="font-family: ,'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;">
        <div class="loading">
            <div class="loading-bg"></div>
            <div class="loading-long">
                <div class="loading-short"></div>
            </div>
        </div>

        <header>
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="/">
                <span class="logo">老胡的星辰随笔</span>
            </a>
        </div>
        <div class="navbar-menu">
            
                <a href="/">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-home'></i> 首页</div>
                        </div>
                    </div>
                </a>
            
                <a href="/posts">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-book'></i> 文章</div>
                        </div>
                    </div>
                </a>
            
                <a href="/tags">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-tags'></i> 标签</div>
                        </div>
                    </div>
                </a>
            
                <a href="/about">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-info-circle'></i> 关于</div>
                        </div>
                    </div>
                </a>
            
            <div class="navbar-burger">
                <div class="burger-btn"><span><i class="fa fa-navicon"></i></span></div>
            </div>
            
            
            <div class="search-in"><span><i class="fa fa-search"></i></span></div>
            
                <div class="mode">
                    <span class="sun"><i class="fa fa-sun-o"></i></span>
                    <span class="moon"><i class="fa fa-moon-o"></i></span>
                </div>
            
        </div>
    </nav>
    <div class="burger-items">
        
        <a href="/">
            <div class="burger-item">
                <i class='fa fa-home'></i> 首页
            </div>
        </a>
        
        <a href="/posts">
            <div class="burger-item">
                <i class='fa fa-book'></i> 文章
            </div>
        </a>
        
        <a href="/tags">
            <div class="burger-item">
                <i class='fa fa-tags'></i> 标签
            </div>
        </a>
        
        <a href="/about">
            <div class="burger-item">
                <i class='fa fa-info-circle'></i> 关于
            </div>
        </a>
        
    </div>
    <div class="header-rest"></div>
</header>


        <div id="content">
    






    
        
    




    <div class="hero">
        
            
                <div class="hero-img">
                    <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/default.jpg" alt="">
                </div>
            
        <div class="hero-content">
            <h1 class="hero-title">标签: IDE</h1>
        </div>
    </div>




<div class="zhuti-0">
    <div class="container">
        <div class="zhuti">
            <div class="zhuti-l">
                




    


<div class="terms-body">
    <div class="long">
        <button class="tosides-1 text-wbd">
            <i class="fa fa-arrow-right"></i>
        </button>
        <button class="tosides-2 text-wbd">
            <i class="fa fa-arrow-left"></i>
        </button>
        <button class="toup text-wbd">
            <i class="fa fa-arrow-up"></i>
        </button>
    </div>
    
        <div class="terms-row">
            
            <div class="terms-root">
                
                



<div class="card-large">
    <div class="card-large-img">

        
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/default.jpg" alt='图片加载失败'>
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="https://hujian.xyz/posts/goland-ide%E8%BF%BD%E6%96%B0/">goland IDE追新</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2023-7-21 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2023-7-23 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                
                    未收录
                
            </span>
        </div>
        <div class="down-summary">追新2023，goland激活码快速激活至2099年！ 当前教程支持的版本：2020.2 ~ GoLand 2023.2 232.8453.111
前言：
goland 软件开发公司 jetbrains 在 2022 年 4 月发布了 goland 2022年第一个大版本2022.1，同时也带来了最严厉的反破解机制，之前所有的破解方案全部失效！在这样的背景下，在奋战了几周左右之后还是成功破解了最新版本2022.1.2！之前的教程中，在破解过程中需要各位码友们自己去操作一些东西，改一下配置，造成了部分不仔细的码友 goland 重启后打不开（虽然后续联系到我修复并激活成功，但是这样确实浪费时间和精力）。同时由于各个版本的配置稍微有些变化，所以本次教程更新给大家带来真正硬核的破解方式：一键脚本激活！！！不需要各位码友有任何多余的操作，只需要双击 vbs 脚本执行，然后重启 goland 就可以完成激活！
注意：本脚本做了向下兼容到2020.1，如果您不想升级，直接执行脚本后重启软件就可以完成激活！
破解过程详解：
1、软件准备 （1）goland 软件安装包（官网下载安全又快速）：https://www.jetbrains.com/goland/download/#section=windows
（2）获取激活码，激活包下载。各位码友们只管关心下图中 golandActive.vbs 脚本文件即可！
网盘地址(2023/07/23更新)：https://pan.baidu.com/s/1hVWbs9z-Deu5RmQ0PO0hTQ?pwd=3fo7
提取码：3fo7
网盘下载后文件zip解压密码：abc1
2、破解过程 2.1软件安装 在官网下载软件后一直点击 Next 即可（已经安装的码友们不用理会），然后打开 goland，发现需要注册！这里我们先不管，先点击 Exit 退出，准备开始运行激活脚本。 2.2 获取激活码 请确保 goland 软件处于关闭状态！ 鼠标双击网盘下载的破解包里面的 golandActive.vbs 得到如下界面，点击确定按钮即可！</div>
    </div>
    <div class="card-readmore">
        <a href="https://hujian.xyz/posts/goland-ide%E8%BF%BD%E6%96%B0/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>



    


    <div class="down-type">
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/ide
                        '>
                    <i class="fa fa-tag"></i> IDE
                </a>
            </div>
        </span>
        
    </div>

<div class="dang"></div>
            </div>
            
        </div>
    
</div>


            </div>
            <div class="zhuti-r">
                
<div class="zhuti-r-0">
    <div class="zhuti-r-1">
        
        <div id="r1">
            

<div class="about-zuozhe">
    <div class="zuozhe">
        
            <div class="datou">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/avatar.png" alt="">
            </div>
        
        <div class="name-jianjie">
            <div class="name">kelly</div>
            <div class="jianjie">
                随笔记录,为技术沉淀.
            </div>
        </div>
    </div>

    <div class="type">
        <a href='
                    /posts/
                '>
            <p>文章</p>
            <p>19</p>
        </a>
        <a href='
                    /categories/
                '>
            <p>分类</p>
            <p>0</p>
        </a>
        <a href='
                    /tags/
                '>
            <p>标签</p>
            <p>8</p>
        </a>
    </div>

    <a href="https://github.com/cappuccino5">
        <div class="follow">Follow Me</div>
    </a>
    <div class="link">
        
        <a href="https://github.com/cappuccino5" class="link-item is-hidden-desktop" title="GitHub">
            <span class="icon"><i class='fa fa-github'></i></span>
        </a>
        
    </div>
</div>
            <div class="mulu">
    <div class="dong"></div>
    <div class="zhi">
        <div class="wenzi">
            <div class="zhi-mulu text-wbd">目录</div>
            <div class="mulu-items">
            </div>
        </div>
    </div>
</div>
            




<div class="other">
    <div class="other-up">
        <div class="other-qita text-wbd">最新文章</div>
        <div class="xian"></div>
    </div>
    <div class="list">
        
            <a href="https://hujian.xyz/posts/gcc13.2%E7%89%88%E6%9C%ACwindwos%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">
                
<a href="https://hujian.xyz/posts/gcc13.2%E7%89%88%E6%9C%ACwindwos%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                gcc windows环境安装(目前13.2版本)
            </div>
            <div class="other-summary">文章目录 1 2 3 4 5 6 7 8 9 10 11 一、简介 1. MinGW 和 MinGW-W64 区别和联系 二、下载 1. 从 sourceforge.net 下载 2. 从 github 下载 3. 从 镜像站点 下载 三、安装与配置 1. 在线安装 2. 离线安装 3. 环境配置 四、总结 一、简介 MinGW 和 MinGW-W64 区别和联系 MinGW和MinGW-W64都是用于Windows平台的轻量级GNU工具链，用于开发和编译C和C++程序。 MinGW（Minimalist GNU for Windows）是一个32位的GNU工具链，它提供了一套基于GNU的开发环境，包括GCC编译器和一些GNU库，可以用来编译Windows下的C和C++程序。但MinGW只支持32位程序的编译。
MinGW-W64是一个64位的GNU工具链，是MinGW的升级版，原本它是MinGW的分支，后来成为独立发展的项目，它支持同时编译32位和64位程序。它包括了一系列的GNU库和工具，例如GCC、Binutils、GDB等，还支持一些实用工具和库，如OpenMP、MPI等。</div>
            <div class="other-date">2023-11-2</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://hujian.xyz/posts/nginx-301%E8%B7%B3%E8%BD%AC%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/">
                
<a href="https://hujian.xyz/posts/nginx-301%E8%B7%B3%E8%BD%AC%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                nginx 301跳转问题总结
            </div>
            <div class="other-summary">1.nginx 301跳转问题背景 在使用hugo部署博客，部署方案nginx+docker,在浏览器地址使用url访问静态资源目录时，发现默认跳转到了http协议的地址。 调出浏览器发现客户端发送的http请求收到了一个301状态码的响应，并且响应头中的Location字段便是跳转到的http协议的地址。 2.原因分析 为啥服务端会返回301呢？首先需要弄清楚状态码的含义。HTTP协议中3xx开头的状态响应码都是表示重定向的响应。根据RFC的定义：
301 Moved Permanently
302 Found
303 See Other
307 Temporary Redirect
301是永久重定向。如果使用Nginx作为HTTP服务器，那么当用户输入一个不存在的地址之后，基本上会有两种情况：1.返回404状态码，2.返回301状态码和重定向地址。404 Not Found不做讨论，只说下301 Moved Permanently的处理过程。 首先需要明确的问题是，301重定向在什么情况下会被触发呢？
答案是：Nginx负责设置301 Moved Permanently状态码。但nginx.conf控制Nginx如何处理301 Moved Permanently状态码！ 换句话说，要不要进行页面重定向，和怎么重定向，完全是用户配置的结果！ Nginx主动设置301 Moved Permanently状态码只有一种情况，当用户在浏览器输入了一个url地址，末尾部分是一个文件目录且不以斜杠”/“结尾，比如 “www.test.com/index” 。 Nginx没有找到index这个文件，但发现了index是个目录。于是本次访问的返回状态码就会被设置成301 Moved Permanently。 浏览器与Nginx的通信过程如下所示：
一般情况下，我们会在nginx.conf中配置absolute_redirect ，server_name_in_redirect和port_in_redirect，以便到达个性化的重定向功能。其中absolute_redirect控制Location url的生成方式。
absolute_redirect设置成on，则生成绝对路径作为Location url。 absolute_redirect设置成off，则生成相对路径作为Location url。 只有absolute_redirect设置为on时，另外两个配置才会生效。
3. 解决方法 设置absolute_redirect为off，构造相对路径作为Location url，示例如下：</div>
            <div class="other-date">2023-7-25</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://hujian.xyz/posts/goland-ide%E8%BF%BD%E6%96%B0/">
                
<a href="https://hujian.xyz/posts/goland-ide%E8%BF%BD%E6%96%B0/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                goland IDE追新
            </div>
            <div class="other-summary">追新2023，goland激活码快速激活至2099年！ 当前教程支持的版本：2020.2 ~ GoLand 2023.2 232.8453.111
前言：
goland 软件开发公司 jetbrains 在 2022 年 4 月发布了 goland 2022年第一个大版本2022.1，同时也带来了最严厉的反破解机制，之前所有的破解方案全部失效！在这样的背景下，在奋战了几周左右之后还是成功破解了最新版本2022.1.2！之前的教程中，在破解过程中需要各位码友们自己去操作一些东西，改一下配置，造成了部分不仔细的码友 goland 重启后打不开（虽然后续联系到我修复并激活成功，但是这样确实浪费时间和精力）。同时由于各个版本的配置稍微有些变化，所以本次教程更新给大家带来真正硬核的破解方式：一键脚本激活！！！不需要各位码友有任何多余的操作，只需要双击 vbs 脚本执行，然后重启 goland 就可以完成激活！
注意：本脚本做了向下兼容到2020.1，如果您不想升级，直接执行脚本后重启软件就可以完成激活！
破解过程详解：
1、软件准备 （1）goland 软件安装包（官网下载安全又快速）：https://www.jetbrains.com/goland/download/#section=windows
（2）获取激活码，激活包下载。各位码友们只管关心下图中 golandActive.vbs 脚本文件即可！
网盘地址(2023/07/23更新)：https://pan.baidu.com/s/1hVWbs9z-Deu5RmQ0PO0hTQ?pwd=3fo7
提取码：3fo7
网盘下载后文件zip解压密码：abc1
2、破解过程 2.1软件安装 在官网下载软件后一直点击 Next 即可（已经安装的码友们不用理会），然后打开 goland，发现需要注册！这里我们先不管，先点击 Exit 退出，准备开始运行激活脚本。 2.2 获取激活码 请确保 goland 软件处于关闭状态！ 鼠标双击网盘下载的破解包里面的 golandActive.vbs 得到如下界面，点击确定按钮即可！</div>
            <div class="other-date">2023-7-21</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://hujian.xyz/posts/kubernetes%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">
                
<a href="https://hujian.xyz/posts/kubernetes%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                kubernetes常用命令
            </div>
            <div class="other-summary">1. 将service端口暴露到本地 比如将生产环境的redis暴露到本地6379端口
1 kubectl port-forward service/redis -n [namesplace] 6379:6379 2. 进入容器中 kubectl exec -it [pod] -n [namesplace] -- bash 3. 查看日志 查看最后1行的日志
kubectl logs -f --tail 1 [pod] -n [namesplace] 查看最后一分钟的所有日志
kubectl -n [namesplace] logs [pod] --since=1m 查看指定时间
kubectl -n -n [namesplace] logs -f [pod] --since-time=&#34;2022-10-24T02:54:03.467+01:00&#34; 4. 查看配置： kubectl get pod product-6b5c98478b-rpgr6 --namespace=product-prod -o yamlkubectl describe pods product-6b5c98478b-rpgr6 --namespace=product-prod 5.</div>
            <div class="other-date">2023-5-10</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://hujian.xyz/posts/ubuntu22.04%E5%AE%89%E8%A3%85gitlab/">
                
<a href="https://hujian.xyz/posts/ubuntu22.04%E5%AE%89%E8%A3%85gitlab/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                ubuntu22.04安装gitlab
            </div>
            <div class="other-summary">1. gitlab安装前准备 系统版本：Ubuntu 22.04.1 LTS 1.1 更新系统环境 sudo apt updatesudo apt upgrade 1.2 安装和配置必须的依赖项 1 2 sudo apt-get install -y curl openssh-server ca-certificates tzdata perl sudo apt-get install curl 2.下载和安装gitlab 2.1 下载指定的版本 1 curl -s https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash 2.2 开始安装 注意：localhost为访问gitlab的地址，85为访问gitlab的端口号
1 sudo EXTERNAL_URL=&#34;http://localhost:85&#34; apt-get install gitlab-ce=15.9.3-ce.0 除非您在安装过程中指定了自定义密码，否则将随机生成一个密码并存储在 /etc/gitlab/initial_root_password文件中(出于安全原因，24 小时后，此文件会被第一次 gitlab-ctl reconfigure 自动删除， 因此若使用随机密码登录，建议安装成功初始登录成功之后，立即修改初始密码）。使用此密码和用户名 root 登录。</div>
            <div class="other-date">2023-4-28</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://hujian.xyz/posts/%E4%BD%BF%E7%94%A8aws-cloudfront%E5%81%9Acdn%E8%BD%AC%E5%8F%91/">
                
<a href="https://hujian.xyz/posts/%E4%BD%BF%E7%94%A8aws-cloudfront%E5%81%9Acdn%E8%BD%AC%E5%8F%91/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                使用aws-cloudfront做CDN转发
            </div>
            <div class="other-summary">CND转发到v2ray服务 环境:
域名一个 aws cloudfront服务 数据转发流程 A.example.com-&gt;cloudfront-&gt;B.example.com-&gt;ip.ec2.port 注意事项 踩过的坑： v2ray-plugin报错 http: TLS handshake error from 64.252.173.97:23912: read tcp 172.21.0.3:443-&gt;64.252.173.97:23912: read: connection reset by peer 原因为2层(EC2,cloudfront)TLS证书不一致; 第一个想法就是将两个证书整成一致，然后cloudfront就上传&quot;Let&rsquo;s Encrypt自签的证书，发现使用自上传的证书cloudfront根本不转发数据了;得出一个结论:cloudfront必须使用它请求生成的tls证书； 解决方案：A.example.com-&gt;cloudfront-&gt;ip.ec2.port转发流程修改为A.example.com-&gt;cloudfront-&gt;B.example.com-&gt;ip.ec2.port v2ray-plugin报错not found in 'Sec-Websocket-Version' header 1 cloudfront ws一直是v2ray.com/core/transport/internet/websocket: failed to convert to WebSocket connection &gt; websocket: unsupported version: 13 not found in &#39;Sec-Websocket-Version&#39; header 原因是cloudfront没有配置转发HTTP请求头,CloudFront 预设并不会转发所有的 HTTP request headers， 有些 request headers 在经过 CloudFront 之后就被丟掉了导致 v2ray 无法识别到必要的数据。 需要更改 origin request policies 為 Managed-AllViewer，這樣它才會轉發所有的 headers。 - 解决方案：cloudfront设置源请求策略为```Managed-AllViewer```cloudfront转发数据到源失败，解决方法是需要更改行为策略-&gt;缓存策略名称(Managed-CachingDisabled)-&gt;源请求策略名称(Managed-AllViewerExceptHostHeader) 源服务器没有接收到数据,错误的提示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 root@localhost ~ # curl -v https://proxy.</div>
            <div class="other-date">2023-3-20</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://hujian.xyz/posts/centos%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/">
                
<a href="https://hujian.xyz/posts/centos%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                centos 7.9离线安装docker
            </div>
            <div class="other-summary">centos 7.9安装docker 1.离线下载docker https://download.docker.com/linux/static/stable/x86_64/docker-20.10.9.tgz 2.离线安装docker 准备前：
2.0.1 关闭Selinux 首先, 执行getenforce或sestatus, 查询selinux状态, CentOS系统安装后默认为enforcing.
getenforce或sestatus 2.0.2 修改selinux配置 1 2 3 4 5 vim /etc/selinux/config 修改selinux配置文件 SELINUX=enforcing 修改为 SELINUX=disabled 2.0.3 重复服务器以上修改生效 1 reboot 2.1 移动文件到目标服务器并执行tar命令解压，如： tar -zxvf docker-20.10.9.tgz 2.2 将/home/docker目录下解压出来的所有docker文件复制到 /usr/bin/ 目录下 cp docker/* /usr/bin/ 2.3 将docker注册为service，进入/etc/systemd/system/目录,并创建docker.service文件 1 2 cd /etc/systemd/system/ touch docker.</div>
            <div class="other-date">2023-3-2</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://hujian.xyz/posts/centos7.7%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/">
                
<a href="https://hujian.xyz/posts/centos7.7%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                centos7.7手动挂载磁盘分区
            </div>
            <div class="other-summary">1. centos挂载磁盘分区 1.1 系统环境 aliyun CentOS Linux release 7.7.1908 (Core) 1.2 目的： 磁盘扩容到256G，主分区(/dev/vda1)使用100G; 剩156G可扩容 1.3 限制条件： 主分区(/dev/vda1)系统盘使用的是ID 83数据卷分区，主分区(/dev/vda1)默认不是lvm，不能实现无缝扩容， 考虑到生产商用环境数据量大，操作风险大，这里用可分配的156G新建分区挂载到系统磁盘/data目录,而不是在主分区上直接扩容 2. 磁盘分区 2.1 查询磁盘大小 1 2 3 4 5 # lsblk -l NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT vda 253:0 0 256G 0 disk vda1 253:1 0 100G 0 part / vda2 253:2 0 156G 0 part 2.</div>
            <div class="other-date">2023-2-27</div>
        </div>
    </div>
</a>
            </a>
        
    </div>
</div>
        </div>
        <div id="r2">
            
        </div> 
    </div>
</div>

            </div>
        </div>
    </div>
</div>


        </div>

        <footer class="footer">
    
        <div class="container">
            <div class="footer-items">
                
                    <div class="footer-item">
                        <i class="fa fa-user"></i> <span id="busuanzi_value_site_pv"></span> |
                        <i class="fa fa-eye"></i> <span id="busuanzi_value_site_uv"></span>
                    </div>
                
                
                    <div class="footer-item">
                        © 2021-2023 <a href="https://github.com/cappuccino5">kelly</a>
                    </div>
                
                
                    <div class="footer-item">
                        Theme by <a href="https://github.com/xioyito/NewBee">NewBee</a> | Powered by <a href="https://gohugo.io/">Hugo</a>
                    </div>
                
            </div>
        </div>
    

    
</footer>


        
        <div class="search-root">
    <div class="search-zz"></div>
    <div class="search">
        <div class="sheader anniu">
            <div class="sh-l">
                <input type="text" placeholder='请输入关键词' id="search-key">
                <span class="sclear"><i class="fa fa-close"></i></span>
            </div>
            <div class="sh-r">
                <button>搜索</button>
            </div>
        </div>
        <div class="sbody">
            <div class="sbody-1">
                <div class="stip"></div>
            </div>
        </div>
    </div>
</div>
        









    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    


<script type="text/javascript">
    var mode_custom = "auto";
    var postsCount =  19 ;
    var arrPosts = [{"link":"https://hujian.xyz/posts/gcc13.2%E7%89%88%E6%9C%ACwindwos%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","plain":"文章目录 1 2 3 4 5 6 7 8 9 10 11 一、简介 1. MinGW 和 MinGW-W64 区别和联系 二、下载 1. 从 sourceforge.net 下载 2. 从 github 下载 3. 从 镜像站点 下载 三、安装与配置 1. 在线安装 2. 离线安装 3. 环境配置 四、总结 一、简介 MinGW 和 MinGW-W64 区别和联系 MinGW和MinGW-W64都是用于Windows平台的轻量级GNU工具链，用于开发和编译C和C++程序。 MinGW（Minimalist GNU for Windows）是一个32位的GNU工具链，它提供了一套基于GNU的开发环境，包括GCC编译器和一些GNU库，可以用来编译Windows下的C和C++程序。但MinGW只支持32位程序的编译。\nMinGW-W64是一个64位的GNU工具链，是MinGW的升级版，原本它是MinGW的分支，后来成为独立发展的项目，它支持同时编译32位和64位程序。它包括了一系列的GNU库和工具，例如GCC、Binutils、GDB等，还支持一些实用工具和库，如OpenMP、MPI等。\n总的来说，MinGW-W64可以看作是MinGW的升级版，它支持更多的编译选项和更多的库，可以编译出更加高效和安全的程序。\n另外，MinGW-W64原本是从MinGW项目fork出来的独立的项目。MinGW 早已停止更新，内置的GCC最高版本为4.8.1，而MinGW-W64目前仍在维护，它也是GCC官网所推荐的。\n二、下载 MinGW-w64 源码地址：\nhttps://github.com/mingw-w64/mingw-w64 官方没在任何地方提供二进制安装程序。 哪里找MinGW-w64二进制应用程序？ 下面提供几种方式：\n1. 从 sourceforge.net 下载(不推荐) 不推荐在这里下载，因为这里提供的二进制安装程序是旧的，支持的GCC版本停留在了\u0026quot;MinGW-W64 GCC-8.1.0\u0026quot;\n下载地址： https://sourceforge.net/projects/mingw-w64/files/\n2. 从 github 下载(推荐) 选择x86_64-13.2.0-release-win32-seh-ucrt-rt_v11-rev0.7z,下载地址：\nhttps://github.com/niXman/mingw-builds-binaries/releases 3. 从镜像站点下载（推荐） 下载地址，选择要安装的版本：\nhttp://files.1f0.de/mingw/ 4. 自己编译源码(不推荐) 三、安装与配置 这里介绍github.com的离线安装方式：\nwindows环境选择 x86_64-13.2.0-release-win32-seh-ucrt-rt_v11-rev0.7z\n下载地址：\nhttps://github.com/niXman/mingw-builds-binaries/releases 配置环境变量：\n将下载的解压到指定目录，如我的windows环境： 把 C:/Sortware/gcc/gccV13.2/ 加入系统环境变量 Path 中去，方便我们命令行使用。 重新打开命令行执行gcc -v\n1 2 3 4 5 6 7 8 9 # gcc -v Using built-in specs. COLLECT_GCC=gcc COLLECT_LTO_WRAPPER=C:/Sortware/gcc/gccV13.2/mingw64/bin/../libexec/gcc/x86_64-w64-mingw32/13.2.0/lto-wrapper.exe Target: x86_64-w64-mingw32 Configured with: ../../../src/gcc-13.2.0/configure --host=x86_64-w64-mingw32 --build=x86_64-w64-mingw32 --target=x86_64-w64-mingw32 --prefix=/mingw64 --with-sysroot=/c/buildroot/x86_64-1320-win32-seh-ucrt-rt_v11-rev0/mingw64 --enable-host-shared --disable-multilib --enable-languages=c,c++,fortran,lto --enable-libstdcxx-time=yes --enable-threads=win32 --enable-libstdcxx-threads=yes --enable-libgomp --enable-libatomic --enable-lto --enable-graphite --enable-checking=release --enable-fully-dynamic-string --enable-version-specific-runtime-libs --enable-libstdcxx-filesystem-ts=yes --disable-libssp --disable-libstdcxx-pch --disable-libstdcxx-debug --enable-bootstrap --disable-rpath --disable-win32-registry --disable-nls --disable-werror --disable-symvers --with-gnu-as --with-gnu-ld --with-arch=nocona --with-tune=core2 --with-libiconv --with-system-zlib --with-gmp=/c/buildroot/prerequisites/x86_64-w64-mingw32-static --with-mpfr=/c/buildroot/prerequisites/x86_64-w64-mingw32-static --with-mpc=/c/buildroot/prerequisites/x86_64-w64-mingw32-static --with-isl=/c/buildroot/prerequisites/x86_64-w64-mingw32-static --with-pkgversion=\u0026#39;x86_64-win32-seh-rev0, Built by MinGW-Builds project\u0026#39; --with-bugurl=https://github.com/niXman/mingw-builds CFLAGS=\u0026#39;-O2 -pipe -fno-ident -I/c/buildroot/x86_64-1320-win32-seh-ucrt-rt_v11-rev0/mingw64/opt/include -I/c/buildroot/prerequisites/x86_64-zlib-static/include -I/c/buildroot/prerequisites/x86_64-w64-mingw32-static/include\u0026#39; CXXFLAGS=\u0026#39;-O2 -pipe -fno-ident -I/c/buildroot/x86_64-1320-win32-seh-ucrt-rt_v11-rev0/mingw64/opt/include -I/c/buildroot/prerequisites/x86_64-zlib-static/include -I/c/buildroot/prerequisites/x86_64-w64-mingw32-static/include\u0026#39; CPPFLAGS=\u0026#39; -I/c/buildroot/x86_64-1320-win32-seh-ucrt-rt_v11-rev0/mingw64/opt/include -I/c/buildroot/prerequisites/x86_64-zlib-static/include -I/c/buildroot/prerequisites/x86_64-w64-mingw32-static/include\u0026#39; LDFLAGS=\u0026#39;-pipe -fno-ident -L/c/buildroot/x86_64-1320-win32-seh-ucrt-rt_v11-rev0/mingw64/opt/lib -L/c/buildroot/prerequisites/x86_64-zlib-static/lib -L/c/buildroot/prerequisites/x86_64-w64-mingw32-static/lib \u0026#39; LD_FOR_TARGET=/c/buildroot/x86_64-1320-win32-seh-ucrt-rt_v11-rev0/mingw64/bin/ld.exe --with-boot-ldflags=\u0026#39; -Wl,--disable-dynamicbase -static-libstdc++ -static-libgcc\u0026#39; Thread model: win32 Supported LTO compression algorithms: zlib gcc version 13.2.0 (x86_64-win32-seh-rev0, Built by MinGW-Builds project) 四、总结 【从sourceforge.net下载】中提供的安装程序，支持的GCC 8.1.0，版本太老了，很多功能不支持，不推荐从这里下载安装； 【2. 从github下载】、【3. 从镜像网站下载】中提供的安装程序，支持的GCC版本都比较新，推荐从这里下载安装；\n五、参考链接： http://lihuaxi.xjx100.cn/news/1433293.html?action=onClick ","pubDate":"2023-11-02","title":"gcc windows环境安装(目前13.2版本)"},{"link":"https://hujian.xyz/posts/nginx-301%E8%B7%B3%E8%BD%AC%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","plain":"1.nginx 301跳转问题背景 在使用hugo部署博客，部署方案nginx+docker,在浏览器地址使用url访问静态资源目录时，发现默认跳转到了http协议的地址。 调出浏览器发现客户端发送的http请求收到了一个301状态码的响应，并且响应头中的Location字段便是跳转到的http协议的地址。 2.原因分析 为啥服务端会返回301呢？首先需要弄清楚状态码的含义。HTTP协议中3xx开头的状态响应码都是表示重定向的响应。根据RFC的定义：\n301 Moved Permanently\n302 Found\n303 See Other\n307 Temporary Redirect\n301是永久重定向。如果使用Nginx作为HTTP服务器，那么当用户输入一个不存在的地址之后，基本上会有两种情况：1.返回404状态码，2.返回301状态码和重定向地址。404 Not Found不做讨论，只说下301 Moved Permanently的处理过程。 首先需要明确的问题是，301重定向在什么情况下会被触发呢？\n答案是：Nginx负责设置301 Moved Permanently状态码。但nginx.conf控制Nginx如何处理301 Moved Permanently状态码！ 换句话说，要不要进行页面重定向，和怎么重定向，完全是用户配置的结果！ Nginx主动设置301 Moved Permanently状态码只有一种情况，当用户在浏览器输入了一个url地址，末尾部分是一个文件目录且不以斜杠”/“结尾，比如 “www.test.com/index” 。 Nginx没有找到index这个文件，但发现了index是个目录。于是本次访问的返回状态码就会被设置成301 Moved Permanently。 浏览器与Nginx的通信过程如下所示：\n一般情况下，我们会在nginx.conf中配置absolute_redirect ，server_name_in_redirect和port_in_redirect，以便到达个性化的重定向功能。其中absolute_redirect控制Location url的生成方式。\nabsolute_redirect设置成on，则生成绝对路径作为Location url。 absolute_redirect设置成off，则生成相对路径作为Location url。 只有absolute_redirect设置为on时，另外两个配置才会生效。\n3. 解决方法 设置absolute_redirect为off，构造相对路径作为Location url，示例如下：\nserver {\rlisten 80;\rabsolute_redirect off;\rserver_name _;\rroot /usr/share/nginx/html;\rlocation /index.html {\radd_header Cache-Control \u0026#34;no-cache, no-store\u0026#34;;\r}\rlocation ~ \\.(css|js|gif|jpg|jpeg|png|svg|ico)$ {\rtry_files $uri =404;\r}\rlocation / {\rproxy_set_header Host $http_host;\rproxy_set_header X-Forwarded-Proto $scheme;\raccess_log /var/log/nginx/web.access.log;\rerror_log /var/log/nginx/web.error.log;\rtry_files $uri $uri/ index.html;\r}\r} 配置后重启nginx,对于 \u0026ldquo;www.test.com/index\u0026quot; 的请求，Location响应头的值将等于 /index/。\n4. 参考连接： https://juejin.cn/post/7021818339651485726 ","pubDate":"2023-07-25","title":"nginx 301跳转问题总结"},{"link":"https://hujian.xyz/posts/goland-ide%E8%BF%BD%E6%96%B0/","plain":"追新2023，goland激活码快速激活至2099年！ 当前教程支持的版本：2020.2 ~ GoLand 2023.2 232.8453.111\n前言：\ngoland 软件开发公司 jetbrains 在 2022 年 4 月发布了 goland 2022年第一个大版本2022.1，同时也带来了最严厉的反破解机制，之前所有的破解方案全部失效！在这样的背景下，在奋战了几周左右之后还是成功破解了最新版本2022.1.2！之前的教程中，在破解过程中需要各位码友们自己去操作一些东西，改一下配置，造成了部分不仔细的码友 goland 重启后打不开（虽然后续联系到我修复并激活成功，但是这样确实浪费时间和精力）。同时由于各个版本的配置稍微有些变化，所以本次教程更新给大家带来真正硬核的破解方式：一键脚本激活！！！不需要各位码友有任何多余的操作，只需要双击 vbs 脚本执行，然后重启 goland 就可以完成激活！\n注意：本脚本做了向下兼容到2020.1，如果您不想升级，直接执行脚本后重启软件就可以完成激活！\n破解过程详解：\n1、软件准备 （1）goland 软件安装包（官网下载安全又快速）：https://www.jetbrains.com/goland/download/#section=windows\n（2）获取激活码，激活包下载。各位码友们只管关心下图中 golandActive.vbs 脚本文件即可！\n网盘地址(2023/07/23更新)：https://pan.baidu.com/s/1hVWbs9z-Deu5RmQ0PO0hTQ?pwd=3fo7\n提取码：3fo7\n网盘下载后文件zip解压密码：abc1\n2、破解过程 2.1软件安装 在官网下载软件后一直点击 Next 即可（已经安装的码友们不用理会），然后打开 goland，发现需要注册！这里我们先不管，先点击 Exit 退出，准备开始运行激活脚本。 2.2 获取激活码 请确保 goland 软件处于关闭状态！ 鼠标双击网盘下载的破解包里面的 golandActive.vbs 得到如下界面，点击确定按钮即可！\n2.3 填入激活码 随后重新启动 goland，会弹出让你激活的的界面。将破解包里面的 激活码.txt 复制进去即可（这里请各位大佬注意！下图中左下角已经登陆的朋友请点击log out），然后点击 蓝色 Activate 按钮即可，接下来就是见证奇迹的时刻！！！\n2.4 查询过期时间 已经激活的朋友如果需要看到第一图的带版本激活信息，在上面激活完成之后，进入编写代码的界面。点击顶部导航栏\nHelp -\u0026gt; About ! 即可看到相应的激活信息！ 最后： 1、关于汉化，goland 软件官方已经提供了汉化插件 File-\u0026gt;Settings-\u0026gt;Plugins 中 MarketPlace 搜索 chinese 安装即可！\n","pubDate":"2023-07-21","title":"goland IDE追新"},{"link":"https://hujian.xyz/posts/kubernetes%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","plain":"1. 将service端口暴露到本地 比如将生产环境的redis暴露到本地6379端口\n1 kubectl port-forward service/redis -n [namesplace] 6379:6379 2. 进入容器中 kubectl exec -it [pod] -n [namesplace] -- bash 3. 查看日志 查看最后1行的日志\nkubectl logs -f --tail 1 [pod] -n [namesplace] 查看最后一分钟的所有日志\nkubectl -n [namesplace] logs [pod] --since=1m 查看指定时间\nkubectl -n -n [namesplace] logs -f [pod] --since-time=\u0026#34;2022-10-24T02:54:03.467+01:00\u0026#34; 4. 查看配置： kubectl get pod product-6b5c98478b-rpgr6 --namespace=product-prod -o yaml\rkubectl describe pods product-6b5c98478b-rpgr6 --namespace=product-prod 5. 从pod复制文件到宿主机 1 kubectl cp redis-test/redis-0:/data/* . 6 复制pod里的文件到宿主机 kubectl cp service-test/redis-0:/data/* . ","pubDate":"2023-05-10","title":"kubernetes常用命令"},{"link":"https://hujian.xyz/posts/ubuntu22.04%E5%AE%89%E8%A3%85gitlab/","plain":"1. gitlab安装前准备 系统版本：Ubuntu 22.04.1 LTS 1.1 更新系统环境 sudo apt update\rsudo apt upgrade 1.2 安装和配置必须的依赖项 1 2 sudo apt-get install -y curl openssh-server ca-certificates tzdata perl sudo apt-get install curl 2.下载和安装gitlab 2.1 下载指定的版本 1 curl -s https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash 2.2 开始安装 注意：localhost为访问gitlab的地址，85为访问gitlab的端口号\n1 sudo EXTERNAL_URL=\u0026#34;http://localhost:85\u0026#34; apt-get install gitlab-ce=15.9.3-ce.0 除非您在安装过程中指定了自定义密码，否则将随机生成一个密码并存储在 /etc/gitlab/initial_root_password文件中(出于安全原因，24 小时后，此文件会被第一次 gitlab-ctl reconfigure 自动删除， 因此若使用随机密码登录，建议安装成功初始登录成功之后，立即修改初始密码）。使用此密码和用户名 root 登录。\n2.3 GitLab配置 2.3.1 修改访问Gitlab服务的地址以及端口 1 2 3 4 5 6 7 sudo vim /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml ## GitLab settings gitlab: ## Web server settings (note: host is the FQDN, do not include http://) host: localhost port: 85 https: true 2.3.2 修改外部访问GitLab的地址 1 2 3 4 # 编辑gitlab.rb文件 sudo vim /etc/gitlab/gitlab.rb # 找到external_url这一项， external_url \u0026#39;http://服务器ip地址:端口\u0026#39; 2.3.3 重新激活配置文件 1 2 3 4 5 # 重新加载配置文件 sudo gitlab-ctl reconfigure 或 # 重启服务 sudo gitlab-ctl restart 2.4 启动GitLab 第一次在浏览器打开时可能会报502错误，可以重启GitLab服务解决。 登录账户：root 查看第一次安装GitLab生成的默认密码：sudo cat /etc/gitlab/initial_root_password\n2.4.1 修改root账户密码 2.4.2 关闭GitLab新用户注册功能 3. 命令操作 3.1 常用命令使用： gitlab-ctl start # 启动所有 gitlab 组件；\rgitlab-ctl stop # 停止所有 gitlab 组件；\rgitlab-ctl restart # 重启所有 gitlab 组件；\rgitlab-ctl status # 查看服务状态；\rgitlab-ctl reconfigure # 刷新配置文件；\rvim /etc/gitlab/gitlab.rb # 修改默认的配置文件；\rgitlab-rake gitlab:check SANITIZE=true --trace # 检查gitlab；\rgitlab-ctl tail # 查看日志； 3.2 命令操作数据备份和恢复 数据迁移要求：\n源主机和目标主机的gitlab版本要求一致 源主机执行备份：\n1 2 3 sudo gitlab-rake gitlab:backup:create # 备份文件会自动存储到目录： /var/opt/gitlab/backups/ 将备份的数据移动到目标主机并放到指定路径：/var/opt/gitlab/backups/\n目标主机执行恢复\n1 2 3 4 5 6 7 8 9 # 停止相关数据连接服务： sudo gitlab-ctl stop unicorn sudo gitlab-ctl stop sidekiq # 修改权限，怕文件因为权限问题无法恢复数据: sudo chmod 775 /var/opt/gitlab/backups/1644308851_2022_02_08_13.3.5_gitlab_backup.tar # 从备份中恢复数据： sudo gitlab-rake gitlab:backup:restore BACKUP=1644308851_2022_02_08_13.3.5 # 备份完重启gitlab gitlab: sudo gitlab-ctl start 4. 升级gitlab版本 查看可用的版本\nwget --content-disposition https://packages.gitlab.com/gitlab/gitlab-ce/packages/ubuntu/jammy/gitlab-ce_15.9.8-ce.0_amd64.deb/download.deb\r// 安装\rdpkg -i ~/gitlab-ce_15.9.8-ce.0_amd64.deb\r// 重启\rgitlab-ctl restart\rgitlab-ctl reconfigure 5.参考链接： gitlab升级降级操作步骤 gitlab版本发布 gitlab数据迁移恢复 ","pubDate":"2023-04-28","title":"ubuntu22.04安装gitlab"},{"link":"https://hujian.xyz/posts/%E4%BD%BF%E7%94%A8aws-cloudfront%E5%81%9Acdn%E8%BD%AC%E5%8F%91/","plain":"CND转发到v2ray服务 环境:\n域名一个 aws cloudfront服务 数据转发流程 A.example.com-\u0026gt;cloudfront-\u0026gt;B.example.com-\u0026gt;ip.ec2.port 注意事项 踩过的坑： v2ray-plugin报错 http: TLS handshake error from 64.252.173.97:23912: read tcp 172.21.0.3:443-\u0026gt;64.252.173.97:23912: read: connection reset by peer 原因为2层(EC2,cloudfront)TLS证书不一致; 第一个想法就是将两个证书整成一致，然后cloudfront就上传\u0026quot;Let\u0026rsquo;s Encrypt自签的证书，发现使用自上传的证书cloudfront根本不转发数据了;得出一个结论:cloudfront必须使用它请求生成的tls证书； 解决方案：A.example.com-\u0026gt;cloudfront-\u0026gt;ip.ec2.port转发流程修改为A.example.com-\u0026gt;cloudfront-\u0026gt;B.example.com-\u0026gt;ip.ec2.port v2ray-plugin报错not found in 'Sec-Websocket-Version' header 1 cloudfront ws一直是v2ray.com/core/transport/internet/websocket: failed to convert to WebSocket connection \u0026gt; websocket: unsupported version: 13 not found in \u0026#39;Sec-Websocket-Version\u0026#39; header 原因是cloudfront没有配置转发HTTP请求头,CloudFront 预设并不会转发所有的 HTTP request headers， 有些 request headers 在经过 CloudFront 之后就被丟掉了导致 v2ray 无法识别到必要的数据。 需要更改 origin request policies 為 Managed-AllViewer，這樣它才會轉發所有的 headers。 - 解决方案：cloudfront设置源请求策略为```Managed-AllViewer```\rcloudfront转发数据到源失败，解决方法是需要更改行为策略-\u0026gt;缓存策略名称(Managed-CachingDisabled)-\u0026gt;源请求策略名称(Managed-AllViewerExceptHostHeader) 源服务器没有接收到数据,错误的提示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 root@localhost ~ # curl -v https://proxy.example.com * About to connect() to proxy.example.com port 443 (#0) * Trying 13.225.103.85... * Connected to proxy.example.com (13.225.103.85) port 443 (#0) * Initializing NSS with certpath: sql:/etc/pki/nssdb * CAfile: /etc/pki/tls/certs/ca-bundle.crt CApath: none * SSL connection using TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 * Server certificate: * subject: CN=proxy.example.com * start date: Apr 15 00:00:00 2023 GMT * expire date: May 14 23:59:59 2024 GMT * common name: proxy.example.com * issuer: CN=Amazon RSA 2048 M01,O=Amazon,C=US \u0026gt; GET / HTTP/1.1 \u0026gt; User-Agent: curl/7.29.0 \u0026gt; Host: proxy.example.com \u0026gt; Accept: */* \u0026gt; \u0026lt; HTTP/1.1 404 Not Found \u0026lt; Content-Length: 0 \u0026lt; Connection: keep-alive \u0026lt; Date: Sat, 15 Apr 2023 06:43:51 GMT \u0026lt; X-Cache: Error from cloudfront \u0026lt; Via: 1.1 69b8510b9be29c1f776639b7e7318dac.cloudfront.net (CloudFront) \u0026lt; X-Amz-Cf-Pop: HKG60-C1 \u0026lt; X-Amz-Cf-Id: -Sm_h3IyQgK6sHFS28lv9leV321FbRd0UiJF5ZlqwJ2bofBw2Uqu9g== \u0026lt; 正确的路由出现Bad Request提示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 root@localhost ~ # curl -v https://proxy.example.com * About to connect() to proxy.example.com port 443 (#0) * Trying 13.225.103.32... * Connected to proxy.example.com (13.225.103.32) port 443 (#0) * Initializing NSS with certpath: sql:/etc/pki/nssdb * CAfile: /etc/pki/tls/certs/ca-bundle.crt CApath: none * SSL connection using TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 * Server certificate: * subject: CN=proxy.example.com * start date: Apr 15 00:00:00 2023 GMT * expire date: May 14 23:59:59 2024 GMT * common name: proxy.example.com * issuer: CN=Amazon RSA 2048 M01,O=Amazon,C=US \u0026gt; GET / HTTP/1.1 \u0026gt; User-Agent: curl/7.29.0 \u0026gt; Host: proxy.example.com \u0026gt; Accept: */* \u0026gt; \u0026lt; HTTP/1.1 400 Bad Request \u0026lt; Content-Type: text/plain; charset=utf-8 \u0026lt; Content-Length: 12 \u0026lt; Connection: keep-alive \u0026lt; Sec-Websocket-Version: 13 \u0026lt; X-Content-Type-Options: nosniff \u0026lt; Date: Sat, 15 Apr 2023 06:52:06 GMT \u0026lt; X-Cache: Error from cloudfront \u0026lt; Via: 1.1 4466aaf3ba3ee7921322175dc8537b7a.cloudfront.net (CloudFront) \u0026lt; X-Amz-Cf-Pop: HKG60-C1 \u0026lt; X-Amz-Cf-Id: BpS3Gy7MhRdnx6qZ28HUxaD1CyUyOfH4bN3jStHo2PLKnh0SBuRIAg== \u0026lt; Bad Request * Connection #0 to host proxy.example.com left intact 参考链接： CloudFront配置HTTP请求头的问题 docker-compose for v2ray ","pubDate":"2023-03-20","title":"使用aws-cloudfront做CDN转发"},{"link":"https://hujian.xyz/posts/centos%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/","plain":"centos 7.9安装docker 1.离线下载docker https://download.docker.com/linux/static/stable/x86_64/docker-20.10.9.tgz 2.离线安装docker 准备前：\n2.0.1 关闭Selinux 首先, 执行getenforce或sestatus, 查询selinux状态, CentOS系统安装后默认为enforcing.\ngetenforce\r或\rsestatus 2.0.2 修改selinux配置 1 2 3 4 5 vim /etc/selinux/config 修改selinux配置文件 SELINUX=enforcing 修改为 SELINUX=disabled 2.0.3 重复服务器以上修改生效 1 reboot 2.1 移动文件到目标服务器并执行tar命令解压，如： tar -zxvf docker-20.10.9.tgz 2.2 将/home/docker目录下解压出来的所有docker文件复制到 /usr/bin/ 目录下 cp docker/* /usr/bin/ 2.3 将docker注册为service，进入/etc/systemd/system/目录,并创建docker.service文件 1 2 cd /etc/systemd/system/ touch docker.service 2.4 编辑docker.service文件,将以下内容复制到docker.service文件中，如下 注1：以下内容中 \u0026ndash;insecure-registry=192.168.0.15 此处改为你自己服务器ip。 或者不填写也可以; 注2：以下内容中 -graph /data/docker 是指定docker root路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 vi docker.service [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service Wants=network-online.target [Service] Type=notify # the default is not to use systemd for cgroups because the delegate issues still # exists and systemd currently does not support the cgroup feature set required # for containers run by docker ExecStart=/usr/bin/dockerd --selinux-enabled=false --insecure-registry=192.168.1.15 #ExecStart=/usr/bin/dockerd --graph /data/docker -H fd:// --containerd=/run/containerd/containerd.sock ExecReload=/bin/kill -s HUP $MAINPID # Having non-zero Limit*s causes performance problems due to accounting overhead # in the kernel. We recommend using cgroups to do container-local accounting. LimitNOFILE=infinity LimitNPROC=infinity LimitCORE=infinity # Uncomment TasksMax if your systemd version supports it. # Only systemd 226 and above support this version. #TasksMax=infinity TimeoutStartSec=0 # set delegate yes so that systemd does not reset the cgroups of docker containers Delegate=yes # kill only the docker process, not all processes in the cgroup KillMode=process # restart the docker process if it exits prematurely Restart=on-failure StartLimitBurst=3 StartLimitInterval=60s [Install] WantedBy=multi-user.target 2.5 给docker.service文件添加执行权限，如下 1 chmod 777 /etc/systemd/system/docker.service 2.6 设置docker日志配置 1 2 3 4 5 6 7 8 9 vi /etc/docker/daemon.json { \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;512m\u0026#34;, \u0026#34;max-file\u0026#34;: \u0026#34;3\u0026#34; } } 2.7 重新加载配置文件，启动docker并设置开机自启动 1 2 3 systemctl daemon-reload systemctl start docker systemctl enable docker.service 2.8 如果非root用户, 安装docker, 还需要将当前用户添加到docker用户组, root用户可以跳过这一步. // 添加用户组\rsudo groupadd docker\rsudo usermod -aG docker $USER\r// 更新用户组\rnewgrp docker 3. 安装docker-compse 3.1 下载二进制文件移动到目标服务器 1 curl -L https://github.com/docker/compose/releases/download/1.24.0-rc3/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 4.查看docker服务运行状态 4.1 查询版本 1 2 3 4 5 docker -v docker version docker-compose -v docker-compose version 4.2 查询docker服务 systemctl status docker 5. docker 配置 docker 配置路径不在路径1就在路径2\n5.1 docker 配置路径1 1 /usr/lib/systemd/system/docker.service 5.2 docker 配置路径2 1 /etc/systemd/system/docker.service ","pubDate":"2023-03-02","title":"centos 7.9离线安装docker"},{"link":"https://hujian.xyz/posts/centos7.7%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/","plain":"1. centos挂载磁盘分区 1.1 系统环境 aliyun CentOS Linux release 7.7.1908 (Core) 1.2 目的： 磁盘扩容到256G，主分区(/dev/vda1)使用100G; 剩156G可扩容 1.3 限制条件： 主分区(/dev/vda1)系统盘使用的是ID 83数据卷分区，主分区(/dev/vda1)默认不是lvm，不能实现无缝扩容， 考虑到生产商用环境数据量大，操作风险大，这里用可分配的156G新建分区挂载到系统磁盘/data目录,而不是在主分区上直接扩容 2. 磁盘分区 2.1 查询磁盘大小 1 2 3 4 5 # lsblk -l NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT vda 253:0 0 256G 0 disk vda1 253:1 0 100G 0 part / vda2 253:2 0 156G 0 part 2.2 查看所有磁盘信息（包括未挂载磁盘） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # fdisk -l Disk /dev/vda: 274.9 GB, 274877906944 bytes, 536870912 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0x000b2d99 Device Boot Start End Blocks Id System /dev/vda1 * 2048 209712509 104855231 83 Linux /dev/vda2 209713152 536870911 163578880 83 Linux Disk /dev/mapper/test_vg-test_lv: 167.5 GB, 167503724544 bytes, 327155712 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes 2.3 创建新的磁盘分区 2.3.1 进入磁盘： 1 fdisk /dev/vda 选择分区号，linux基本分区和扩展分区之和不能大于4，所以在1-4直接选择，一般是从大到小按编号选：输入命令n，然后输入1。 输入命令t，然后输入分区类型，输入83表示数据卷分区 输入命令w，重写分区表 2.3.2 查看创建的分区 使用fdisk -l查看创建的分区，有时候会看不到创建的新分区，此时使用fdisk命令看不到新建的分区信息。\npartprobe 是一个可以修改kernel中分区表的工具，可以使kernel重新读取分区表而不用重启系统。命令：\npartprobe /dev/vda\n将物理硬盘分区初始化为物理卷，以便LVM使用：\npvcreate /dev/vda2\n2.4 创建卷组和逻辑卷并格式化 创建卷组test_vg:\nvgcreate test_vg /dev/vda2\n创建逻辑卷test_lv并分配磁盘空间：\nlvcreate -l +156%FREE -n test_lv test_vg\n查看磁盘空间使用情况：\ndf -mh 格式化逻辑卷：\nmkfs.ext4 /dev/test_vg/test_lv 2.5 创建目录将新的分区挂载到创建的目录 创建目录data：\nmkdir /data\n挂载目录:\nmount /dev/test_vg/test_lv /data\npartprobe显示资源正忙，这种情况，需要重启服务器才行：\npartprobe\n2.6 设置分区在系统重启后自动挂载,在文件追加（未验证）： 1 2 3 # vi /etc/fstab /dev/test_vg/test_lv /data ext4 default 0 0 3. 重启后磁盘挂载失效重新挂载 3.1 查询磁盘挂载状态示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 [root@iZwz9cram8gccy39lygvdfZ ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT vda 253:0 0 256G 0 disk |-vda1 253:1 0 100G 0 part / `-vda2 253:2 0 156G 0 part `-test_vg-test_lv 252:0 0 156G 0 lvm /data [root@iZwz9cram8gccy39lygvdfZ ~]# vgs VG #PV #LV #SN Attr VSize VFree test_vg 1 1 0 wz--n- 156.00g 0 [root@iZwz9cram8gccy39lygvdfZ ~]# lvscan ACTIVE \u0026#39;/dev/test_vg/test_lv\u0026#39; [156.00 GiB] inherit [root@iZwz9cram8gccy39lygvdfZ ~]# lvdisplay --- Logical volume --- LV Path /dev/test_vg/test_lv LV Name test_lv VG Name test_vg LV UUID bHGWWb-CC0V-3vFB-oE3j-7lPg-fkIw-XB28oZ LV Write Access read/write LV Creation host, time iZwz9cram8gccy39lygvdfZ, 2022-11-29 12:19:09 +0800 LV Status available # open 1 LV Size 156.00 GiB Current LE 39936 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 252:0 3.2 修改逻辑卷分组状态: [root@iZwz9cram8gccy39lygvdfZ ~]# vgchange -a y test_vg\r1 logical volume(s) in volume group \u0026#34;test_vg\u0026#34; now active 3.3 命令解释： lsblk -l // 查询系统磁盘分配属性\rvgs // 查看卷组的属性\rpvdisplay // 查看物理卷\rvgdisplay // 查看逻辑卷\rlvdisplay // 查看逻辑卷状态\rlvscan // 查看存在的所有LVM逻辑卷\rvgchange -a y test_vg // 重新激活逻辑卷分组\rmount /dev/test_vg/test_lv /data // 重新挂载逻辑卷到指定目录 4.参考连接 aliyun文档-通过LVM扩容逻辑卷 aliyun文档-通过LVM创建逻辑卷-本文使用的方法 ","pubDate":"2023-02-27","title":"centos7.7手动挂载磁盘分区"},{"link":"https://hujian.xyz/posts/windows%E5%AE%89%E8%A3%85ubuntu22.04/","plain":"1.安装前准备 U盘\u0026gt;=8G，干净的U盘，因为在安装过程中会清除U盘数据; Windows 7 或更高版本 (32/64 位均可)。 U盘安装引导依赖2选1,建议选Rufus： U盘引导安装依赖uboot - https://github.com/balena-io/etcher/releases/download/v1.18.4/balenaEtcher-Setup-1.18.4.exe U盘引导依赖-Rufus 下载ubuntu镜像选择对应的系统架构版本，建议选择官方，如果下载速度慢则选择aliyun：\n官方下载ubuntu22.04桌面版本 阿里云镜像源ubuntu22.04桌面版本 ubuntu-arm架构镜像源 2.U盘制作安装引导 将下载好的rufus和ubuntu22.04镜像放到U盘中 执行rufus二进制文件，按步骤执行： 选择对应的U盘位置 选择ubuntu镜像文件并选择打开 选择START执行写入U盘，可能需要额外的资源来写入ISO，弹窗选择yes；在执行中可能遇到一些警告说会清空U盘，选择OK; 安装引导过程总共需要约10分钟,安装完成后状态栏为READY，此时选择CLOSE,安装完成; 3. 安装ubuntu U盘制作好安装引导后在目标机器上执行：\n重启电脑，在启动过程中按F12或者F10或者F2(根据电脑品牌选择不同)进入boot菜单，在菜单中选择USB boot菜单中选择语言，continue进入下一步 安装ubuntu步骤：选择normal installation；如果电脑给的配置很低，就选择minimal installation； 配置安装：install type配置来选择是否将ubuntu作为您唯一的操作系统(此选择会删除windows系统并清除磁盘);如果当前有windows系统则可以选择双系统共同安装; 存储卷LVM选择安全加密，并设置密码 用于恢复数据;密码记录下来保存在其它地方; 创建你的登录账号密码和计算机名字，continue继续 等待进度条，100%完成安装，并选择重启 参考链接 Install Ubuntu desktop bootable引导 ","pubDate":"2023-02-10","title":"windows安装ubuntu22.04"},{"link":"https://hujian.xyz/posts/centos7.9%E6%89%A9%E5%B1%95%E7%A3%81%E7%9B%98/","plain":"1. centos 扩展磁盘分区 1.1 系统环境1 vmware centos 7.9 2.扩展步骤 2.1 步骤一 关机状态下在设置-\u0026gt;硬盘-\u0026gt;扩展-\u0026gt;选择硬盘大小; 我这里选择扩展到50G\n2.2 步骤二 进入系统内部执行命令扩展磁盘大小，主要是创建逻辑卷(PVC)/物理卷(PV),从逻辑卷(LV)映射到物理卷(PV): 1 2 3 4 5 6 7 8 9 10 11 12 13 df -mh lsblk -l // 查询系统磁盘挂载目录 fdisk -l pvcreate /dev/sda3 vgextend centos /dev/sda3 vgs // 返回卷组的属性 pvdisplay // 查看物理卷 vgdisplay // 查看逻辑卷 lvdisplay // 查看逻辑卷状态 lvextend -L +50G /dev/test_vg/test_lv // 分配指定大小 lvextend -l +100%FREE /dev/centos/root // 分配100的剩余空间 xfs_growfs /dev/mapper/centos-root // 刷新根分区生效 df -mh // 查询磁盘 系统重启更新重新挂载磁盘卷 1 2 3 lvdisplay // 查看逻辑卷状态 vgchange -a y test_vg // 重新激活逻辑卷组 mount /dev/test_vg/test_lv /data // 重新挂载逻辑卷到指定目录 2.2.1 执行扩展示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 root@localhost ~ # df -mh Filesystem Size Used Avail Use% Mounted on devtmpfs 969M 0 969M 0% /dev tmpfs 980M 0 980M 0% /dev/shm tmpfs 980M 9.9M 970M 2% /run tmpfs 980M 0 980M 0% /sys/fs/cgroup /dev/mapper/centos-root 17G 14G 3.3G 81% / /dev/sda1 1014M 299M 716M 30% /boot overlay 17G 14G 3.3G 81% /var/lib/docker/overlay2/0971f73c015ca770356f4ba4b30afeaf8a5bab897787d00fb12e976013c816b4/merged overlay 17G 14G 3.3G 81% /var/lib/docker/overlay2/080f5771c97382cba9de40fc04cc449d661831cb6404d1165ba5f9d94ff097a4/merged overlay 17G 14G 3.3G 81% /var/lib/docker/overlay2/418d6d02082ce2c868843e06cf9bbcefc8d854620a779e5d40c9e818ddc9ff8b/merged overlay 17G 14G 3.3G 81% /var/lib/docker/overlay2/1a3310ec1ffe14dc972c46ecc56cae627c66ac6ea22d8ec86a7ee341ab395a3a/merged shm 64M 0 64M 0% /var/lib/docker/containers/89721e8e469f187ee631632a86e158c752ae93b901bdc968567231797e24d6f0/mounts/shm shm 64M 0 64M 0% /var/lib/docker/containers/65e865a368434ff6d6ead1bd3eae5566dc3c75eeb8b747ec6bebc046a6d94d14/mounts/shm shm 64M 0 64M 0% /var/lib/docker/containers/2be6579cd347c2b993e85cd17289dc6205aeb0fa2e566e99893b31c66fc6ea37/mounts/shm shm 64M 16K 64M 1% /var/lib/docker/containers/039aef669459f804f306b710b845c090efcad0a0359cc9aa3428580dc0117b2b/mounts/shm tmpfs 196M 0 196M 0% /run/user/0 root@localhost ~ # fdisk -l root@localhost ~ # pvcreate /dev/sda3 Physical volume \u0026#34;/dev/sda3\u0026#34; successfully created. root@localhost ~ # vgextend centos /dev/sda3 Volume group \u0026#34;centos\u0026#34; successfully extended root@localhost ~ # vgs VG #PV #LV #SN Attr VSize VFree centos 2 2 0 wz--n- 48.99g \u0026lt;30.00g root@localhost ~ # vgdisplay --- Volume group --- VG Name centos System ID Format lvm2 Metadata Areas 2 Metadata Sequence No 4 VG Access read/write VG Status resizable MAX LV 0 Cur LV 2 Open LV 2 Max PV 0 Cur PV 2 Act PV 2 VG Size 48.99 GiB PE Size 4.00 MiB Total PE 12542 Alloc PE / Size 4863 / \u0026lt;19.00 GiB Free PE / Size 7679 / \u0026lt;30.00 GiB VG UUID vFfONo-DxPv-pnCQ-lPtz-3gCe-8dqz-dqFywm root@localhost ~ # pvdisplay --- Physical volume --- PV Name /dev/sda2 VG Name centos PV Size \u0026lt;19.00 GiB / not usable 3.00 MiB Allocatable yes (but full) PE Size 4.00 MiB Total PE 4863 Free PE 0 Allocated PE 4863 PV UUID tiJXzP-GDDT-o2Nb-M3sZ-LjpH-mJhD-82rx1B --- Physical volume --- PV Name /dev/sda3 VG Name centos PV Size 30.00 GiB / not usable 4.00 MiB Allocatable yes PE Size 4.00 MiB Total PE 7679 Free PE 7679 Allocated PE 0 PV UUID 0tXB8b-zDVW-f0xz-7zpy-sfhc-A7dh-29te0U root@localhost ~ # lvextend -L +29.9G /dev/mapper/centos-root Rounding size to boundary between physical extents: 29.90 GiB. Size of logical volume centos/root changed from \u0026lt;17.00 GiB (4351 extents) to \u0026lt;46.90 GiB (12006 extents). Logical volume centos/root successfully resized. # resize2fs /dev/mapper/centos-root resize2fs 1.42.9 (28-Dec-2013) resize2fs: Bad magic number in super-block while trying to open /dev/mapper/centos-root Couldn\u0026#39;t find valid filesystem superblock. root@localhost ~ # xfs_growfs /dev/mapper/centos-root meta-data=/dev/mapper/centos-root isize=512 agcount=4, agsize=1113856 blks = sectsz=512 attr=2, projid32bit=1 = crc=1 finobt=0 spinodes=0 data = bsize=4096 blocks=4455424, imaxpct=25 = sunit=0 swidth=0 blks naming =version 2 bsize=4096 ascii-ci=0 ftype=1 log =internal bsize=4096 blocks=2560, version=2 = sectsz=512 sunit=0 blks, lazy-count=1 realtime =none extsz=4096 blocks=0, rtextents=0 data blocks changed from 4455424 to 12294144 root@localhost ~ # df -mh Filesystem Size Used Avail Use% Mounted on devtmpfs 969M 0 969M 0% /dev tmpfs 980M 0 980M 0% /dev/shm tmpfs 980M 9.9M 970M 2% /run tmpfs 980M 0 980M 0% /sys/fs/cgroup /dev/mapper/centos-root 47G 14G 34G 30% / /dev/sda1 1014M 299M 716M 30% /boot overlay 47G 14G 34G 30% /var/lib/docker/overlay2/0971f73c015ca770356f4ba4b30afeaf8a5bab897787d00fb12e976013c816b4/merged overlay 47G 14G 34G 30% /var/lib/docker/overlay2/080f5771c97382cba9de40fc04cc449d661831cb6404d1165ba5f9d94ff097a4/merged overlay 47G 14G 34G 30% /var/lib/docker/overlay2/418d6d02082ce2c868843e06cf9bbcefc8d854620a779e5d40c9e818ddc9ff8b/merged overlay 47G 14G 34G 30% /var/lib/docker/overlay2/1a3310ec1ffe14dc972c46ecc56cae627c66ac6ea22d8ec86a7ee341ab395a3a/merged shm 64M 0 64M 0% /var/lib/docker/containers/89721e8e469f187ee631632a86e158c752ae93b901bdc968567231797e24d6f0/mounts/shm shm 64M 0 64M 0% /var/lib/docker/containers/65e865a368434ff6d6ead1bd3eae5566dc3c75eeb8b747ec6bebc046a6d94d14/mounts/shm shm 64M 0 64M 0% /var/lib/docker/containers/2be6579cd347c2b993e85cd17289dc6205aeb0fa2e566e99893b31c66fc6ea37/mounts/shm shm 64M 16K 64M 1% /var/lib/docker/containers/039aef669459f804f306b710b845c090efcad0a0359cc9aa3428580dc0117b2b/mounts/shm tmpfs 196M 0 196M 0% /run/user/0 3.参考： https://blog.csdn.net/chengyuqiang/article/details/59491942 https://blog.runm.top/?p=1109 ","pubDate":"2023-01-02","title":"centos7.9扩展磁盘"},{"link":"https://hujian.xyz/posts/ubuntu%E5%AE%BF%E4%B8%BB%E6%9C%BA%E9%83%A8%E7%BD%B2ss-local%E5%AE%A2%E6%88%B7%E7%AB%AF/","plain":"shadowsocks-libev基于ubuntu宿主机部署ss-local客户端.md 1. 安装 1.1 准备环境： Linux ubuntu 6.2.0-20-generic ubuntu 2023-04 amd64 基于ubuntu宿主机安装 shadowsocks-libev和v2ray-plugin 1.2 安装shadowsocks-libev： sudo apt install shadowsocks-libev\r1.3 安装v2ray-plugin 1 2 3 4 wget https://github.com/shadowsocks/v2ray-plugin/releases/download/v1.3.2/v2ray-plugin-linux-amd64-v1.3.2.tar.gz tar -zxvf v2ray-plugin-linux-amd64-v1.3.2.tar.gz mv v2ray-plugin_linux_amd64 /usr/bin/v2ray-plugin chmod 775 /usr/bin/v2ray-plugin 1.3 配置shadowsocks-libev配置文件 vi /etc/shadowsocks-libev/config.json\r{\r\u0026#34;server\u0026#34;: \u0026#34;domain.com\u0026#34;,\r\u0026#34;server_port\u0026#34;: 443,\r\u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;,\r\u0026#34;method\u0026#34;: \u0026#34;aes-128-gcm\u0026#34;,\r\u0026#34;local_address\u0026#34;: \u0026#34;0.0.0.0\u0026#34;,\r\u0026#34;local_port\u0026#34;: 1080,\r\u0026#34;plugin\u0026#34;: \u0026#34;/usr/bin/v2ray-plugin\u0026#34;,\r\u0026#34;plugin_opts\u0026#34;: \u0026#34;tls;host=domain.com;path=/\u0026#34;,\r\u0026#34;plugin_args\u0026#34;: \u0026#34;\u0026#34;,\r\u0026#34;remarks\u0026#34;: \u0026#34;proxy\u0026#34;,\r\u0026#34;timeout\u0026#34;: 10,\r\u0026#34;mode\u0026#34;: \u0026#34;tcp_and_udp\u0026#34;\r} 1.4 把shadowsocks-libe.service的ss-server修改成ss-local 1 2 3 4 5 cat /lib/systemd/system/shadowsocks-libev.service ExecStart=/usr/bin/ss-local -c $CONFFILE $DAEMON_ARGS sudo systemctl daemon-reload sudo systemctl restart shadowsocks-libev 2. 测试ip代理是否成功 curl -v ip.gs // 能成功显示代理IP则成功\rcurl --socks5 127.0.0.1:1080 https://www.google.com // 测试是否能访问google 3. 配置http_proxy： v2ray-plugs是用的socks5协议，所以本地走代理的话需要配置http_proxy=socks5\n3.1 临时配置http_proxy export http_proxy=socks5://127.0.0.1:1080\rexport https_proxy=$http_proxy 3.2 永久配置http_proxy 1 2 3 4 5 6 7 8 9 vi /etc/profile PROXY_HOST=127.0.0.1 PROXY_PORT=1080 export http_proxy=socks5://$PROXY_HOST:$PROXY_PORT export https_proxy=$http_proxy export no_proxy=localhost,172.16.0.0/16,192.168.0.0/16.,127.0.0.1,10.10.0.0/16,192.168.159.0/24,192.168.171.0/24 source /etc/profile 4. 取消http_proxy代理 unset http_proxy\runset https_proxy 5. 参考 v2ray各种系统配置示例\nhttps://github.com/v2fly/v2ray-examples/blob/master/Shadowsocks-Websocket-Web-TLS/config_client.json socks5配置参考：\nhttps://gist.github.com/yougg/5d2b3353fc5e197a0917aae0b3287d64 ","pubDate":"2022-08-10","title":"ubuntu宿主机部署ss-local客户端"},{"link":"https://hujian.xyz/posts/%E4%BD%BF%E7%94%A8cloudflare%E8%BD%AC%E5%8F%91ssh%E7%AB%AF%E5%8F%A3/","plain":"Cloudflare Tunnel cloudflare 提供的免费加密通道，通过 cloudflare 的 cnd 访问部署在内网的服务，比如 web,ssh,smb,tcp 等。 其工作方式类似于 frp，可以将本地服务发布到公网。只不过 frp 所需的服务器 IP 在 Cloudflare Tunnel 中变成了 Cloudflare 提供的节点。 相比于 frp 省去了服务器的成本。\n1.准备 1.1 先决条件 必须需要一个 cloudflare 账号，以及开通 cloudflare zero trust。 cloudflare：https://www.cloudflare.com/ zero trust: https://one.dash.cloudflare.com/ 在你的需要内网穿透的设备上安装 cloudflared（cf 的本地 cli 客户端）\nubuntu/centos amd64架构 curl -L 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64' -o /usr/bin/cloudflared \u0026amp;\u0026amp; chmod +x /usr/bin/cloudflared arm64 curl -L 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-arm64' -o /usr/bin/cloudflared\rchmod +x /usr/bin/cloudflared 用命令登录cloudflared\ncloudflared tunnel login 终端会给出一个类似 https://dash.cloudflare.com/argotunnel?callback=https%3A%2F%2Flogin.cloudflareaccess.org%xxxxxxxxxxxxxxxxxxxxxxx 的登陆地址，复制黏贴该地址到浏览器中，然后按照要求登录即可。\r如果是有二步验证的，需要登录了以后，再次黏贴该地址，因为二步验证结束后并不会自动跳转到该 cloudflared 验证登录页面。\r授权的话，每次只能选择一个网站，当然，一个网站也就够用了，我们可以解析很多三级域名。\r当然如果需要授权多个网站，授权完成后不要关闭网页！依次点击其他需要授权的域名，进行多次授权。 2. 在目标机器上设置要转发SSH服务器 授权完成后，就可以创建我们需要的隧道了。cloudflare 提供两种方式;\n一种是在 zero trust 页面用 web 添加授权 在本地服务器（raspberry）上用 config 文件添加 下面用的是 config 文件添加，因为本地 config 更方便操作一些,如果有多台服务器，那么可以在不同的服务器安装多个Cloudflared，配置多个Tunnel\n2.1 创建tunnel 创建完以后，会把信息保存到 root 下的 .cloudflared 文件夹下，注意不要误删了\ncloudflared tunnel create \u0026lt;你的隧道名字\u0026gt; 示例： cloudflared tunnel create amd-test 2.2 创建域名 CNAME 添加一个域名:\ncloudflared tunnel route dns \u0026lt;隧道名字\u0026gt; \u0026lt;域名\u0026gt; 示例 cloudflared tunnel route dns amd-test test.hujian.xyz 然后 cloudflare 就会在你的域名下自动生成一个 CNAME，把 test.hujian.xyz 指向 \u0026lt;隧道 UUID\u0026gt;.cfargotunnel.com\n以此类推，我们可以如法炮制在面板上添加其他的需要的 CNAME\n2.3 配置 Config 文件 添加好想要穿透的域名后，我们就可以开始映射了。\n1 2 3 4 5 6 7 8 9 # vi ~/.cloudflared/config.yml tunnel: \u0026lt;隧道UUID\u0026gt; credentials-file: /root/.cloudflared/\u0026lt;隧道UUID\u0026gt;.json ingress: - hostname: test.hujian.xyz service: ssh://localhost:22 - service: http_status:404 注意：最后的 - service: http_status:404 一定要加，这是兜底的规则。还有复制黏贴的时候确保格式没有错误，很可能会发生 mapping error。\n2.4 配置完以后，可以测试下配置文件是否有问题。 1 2 3 # cloudflared --config ~/.cloudflared/config.yaml tunnel ingress validate Validating rules from /root/.cloudflared/config.yaml OK 2.5 启动服务 如果不指定配置文件路径，cloudflared 会默认读取 ~/.cloudflared/config.yml\ncloudflared tunnel --config [配置文件路径] run 示例：cloudflared tunnel --config config.yaml run\n3. 创建 systemctl 开机自启动服务 cloudflared service install\rsystemctl start cloudflared\rsystemctl enable cloudflared\rsystemctl status cloudflared 4. SSH 客户端使用 4.1 客户端也要安装cloudflared，参考准备-先决条件 4.2 更改 SSH 配置文件 1 2 3 4 $ vi ~/.ssh/config Host ssh.example.com ProxyCommand /usr/local/bin/cloudflared access ssh --hostname %h 4.3 运行ssh命令访问服务器 ssh \u0026lt;username\u0026gt;@ssh.example.com\n运行该命令时，cloudflared将生成连接，提示您在从终端建立连接之前通过您的身份提供者进行身份验证。\n示例： 1 https://test.hujian.xyz/cdn-cgi/access/cli?edge_token_transfer=true\u0026amp;redirect_url=https%3A%2F%2Fgo.hujian.xyz%3Ftoken%3Dr2BxxxmiFzTisCZxN8KJtm_wjTyFHK3E%253D\u0026amp;send_org_token=true\u0026amp;token=r2xxxxzxxx_wxyFHK3E%3D 5 参考 EdNovas 的小站 官方连接-SSH through Cloudflare Tunnel ","pubDate":"2022-07-21","title":"使用cloudflare转发ssh端口"},{"link":"https://hujian.xyz/posts/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E5%A4%96%E9%93%BE/","plain":"1. 博客底部添加音乐组件 音乐效果\n1.1 直接上代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;!-- 为博客底部添加音乐组件 --\u0026gt; \u0026lt;div id=\u0026#34;player\u0026#34; class=\u0026#34;aplayer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;link href=\u0026#34;https://files.cnblogs.com/files/shwee/APlayer.min_v1.10.1.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://files.cnblogs.com/files/shwee/APlayer.min_v1.10.1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var ap = new APlayer({ element: document.getElementById(\u0026#39;player\u0026#39;), narrow: false, loop: \u0026#39;all\u0026#39;,\u0026lt;!-- 全部循环 --\u0026gt; order: \u0026#39;random\u0026#39;,\u0026lt;!-- 随机循环 --\u0026gt; volume: 0.2,\u0026lt;!-- 播放音量 --\u0026gt; autoplay: true, \u0026lt;!-- 是否自动播放 --\u0026gt; showlrc: true, \u0026lt;!--是否开启歌词功能 ，默认false（为true时musics集合中需要传入lrc字段。）--\u0026gt; fixed:1,\u0026lt;!-- 是否固定在左下角不动， 1即为true --\u0026gt; theme: \u0026#39;#F5F5F5\u0026#39;, \u0026lt;!-- 插件背景颜色，建议和你的公告栏背景色一样，这样融为一体的感觉 --\u0026gt; music: [ { title: \u0026#39;世间美好与你环环相扣\u0026#39;, author: \u0026#39;柏松\u0026#39;, url: \u0026#39;http://music.163.com/song/media/outer/url?id=1363948882.mp3\u0026#39;, pic: \u0026#39;http://p1.music.126.net/DK1_4sP_339o5rowMdPXdw==/109951164071024476.jpg?param=300x300\u0026#39;, lrc: \u0026#39;[00:00.000] 作词 : 尹初七[00:01.000] 作曲 : 柏松[00:02.000] 编曲 : 彭圣杰[00:15.554][00:28.054]偏偏秉烛夜游[00:31.054]午夜星辰 似奔走之友[00:34.554]爱你每个结痂伤口[00:37.554]酿成的陈年烈酒[00:40.804][00:41.804]入喉尚算可口[00:44.803]怎么泪水 还偶尔失守[00:48.553]邀你细看心中缺口[00:51.053]裂缝中留存 温柔[00:55.804][00:57.553]此时已莺飞草长 爱的人正在路上[01:01.802]我知他风雨兼程 途经日暮不赏[01:05.552]穿越人海 只为与你相拥[01:11.552]此刻已皓月当空 爱的人手捧星光[01:15.302]我知他乘风破浪 去了黑暗一趟[01:19.052]感同身受 给你救赎热望[01:25.302][01:26.052]知道你不能 还要你感受[01:29.802]让星光加了一点彩虹[01:32.802]让樱花偷偷 吻你额头[01:36.553]让世间美好 与你环环相扣[01:41.303][01:42.052]此时已莺飞草长 爱的人正在路上[01:46.302]我知他风雨兼程 途经日暮不赏[01:50.302]穿越人海 只为与你相拥[01:55.802]此刻已皓月当空 爱的人手捧星光[01:59.802]我知他乘风破浪 去了黑暗一趟[02:04.052]感同身受 给你救赎热望[02:09.051][02:09.551]此时已莺飞草长 爱的人正在路上[02:13.550]我知他风雨兼程 途经日暮不赏[02:17.801]穿越人海 只为与你相拥[02:23.301]此刻已皓月当空 爱的人手捧星光[02:27.550]我知他乘风破浪 去了黑暗一趟[02:31.551]感同身受 给你救赎热望[02:37.051][02:38.300]知道你不能 还要你感受[02:41.300]让星光加了一点彩虹[02:44.800]当樱花开的纷纷扬扬[02:48.301]当世间美好 与你环环相扣[02:58.300]特别鸣谢：槿葵，我们的海报制作妹妹。[03:05.554]原唱：柏松[03:06.055]吉他：柏松[03:07.054]和声：柏松[03:07.804]录音：柏松[03:08.804]混音：张强\u0026#39; }, { title: \u0026#39;阿拉斯加海湾\u0026#39;, author: \u0026#39;蓝心羽\u0026#39;, url: \u0026#39;http://music.163.com/song/media/outer/url?id=1500569811.mp3\u0026#39;, pic: \u0026#39;http://p2.music.126.net/CbWwREaA22LmAv1oOtJt2w==/109951165518862422.jpg?param=300x300\u0026#39;, lrc: \u0026#39;[00:00.000] 作词 : 菲道尔/李康宁[00:00.299] 作曲 : 菲道尔[00:00.598]原唱：菲道尔[00:01.605]演唱：蓝心羽[00:02.606]编曲：于山川@Cstudio[00:03.608]贝斯：石间@Cstudio[00:04.604]吉他：丁兆尊龙[00:05.358]和声编写：田跃君[00:06.360]和声：蓝心羽[00:07.108]混音：王巍MOKA[00:08.115]制作人：杜叔叔[00:09.105]策划统筹：文氓苏[00:10.107]宣发：张婧、寂瞳、游文雅、杜钰雯[00:10.851]OP：Loolala Music M Sdn. Bhd.[00:11.777]SP：环球音乐版权管理集团(Universal Music Publishing CHINA)[00:13.198]音乐制作：极韵文化\u0026amp;BLUE STUDIO[00:14.446]音乐发行：极韵文化\u0026amp;BLUE STUDIO[00:15.448]出品：「极韵文化」×「BLUE STUDIO」×「造音行动」[00:16.698]【此版本为正式授权翻唱作品】[00:21.950]上天啊[00:24.990]难道你看不出我很爱她[00:29.110]怎么明明相爱的两个人[00:32.560]你要拆散他们啊[00:38.730]上天啊[00:41.630]你千万不要偷偷告诉她[00:45.940]在无数夜深人静的夜晚[00:49.550]有个人在想她[00:54.710]以后的日子你要好好照顾她[01:03.088]我不在她身旁你不能欺负她[01:11.209]别再让人走进她心里[01:15.679]最后却又离开她[01:20.539]因为我不愿再看她流泪啦[01:41.268]上天啊[01:44.250]你是不是在偷偷看笑话[01:48.349]明知我还没能力保护她[01:52.110]让我们相遇啊[01:58.149]上天啊[02:00.868]她最近是否不再失眠啦[02:05.108]愿世间温情化作一缕风[02:08.800]代替我拥抱她[02:14.068]以后的日子你要好好照顾她[02:22.288]我不在她身旁你不能欺负她[02:30.558]别再让人走进她心里[02:34.679]最后却又离开她[02:39.929]因为我不愿再看她流泪啦[02:47.498]希望我的努力能够赶上她[02:55.710]有天我能给她完整的一个家[03:04.110]可若你安排了别人给她[03:09.098]我会祝福她[03:12.938]上天你别管我先让她幸福吧[03:21.330]上天啊[03:24.399]这些晚上我对你说的话[03:28.619]你别不小心漏嘴告诉她[03:32.300]我怕会吵醒她[03:38.339]上天啊[03:41.429]你千万不要偷偷告诉她[03:45.580]在无数夜深人静的夜晚[03:49.248]我依旧在想她\u0026#39; }, ] }); ap.init(); \u0026lt;/script\u0026gt; 2. 自定义歌曲 2.1 url默认公式：把从网易云获取的id与下面的****替换 http://music.163.com/song/media/outer/url?id=****.mp3 网易云音乐- 阿拉斯加海湾 - 蓝心羽 2.2 对应的播放模式，可以修改下面的代码 1 2 3 4 5 6 7 8 9 10 11 mini: false, //迷你模式 autoplay: false, //自动播放 theme: \u0026#39;#FADFA3\u0026#39;, //主题色 loop: \u0026#39;all\u0026#39;, //音频循环播放, 可选值: \u0026#39;all\u0026#39;全部循环, \u0026#39;one\u0026#39;单曲循环, \u0026#39;none\u0026#39;不循环 order: \u0026#39;random\u0026#39;, //音频循环顺序, 可选值: \u0026#39;list\u0026#39;列表循环, \u0026#39;random\u0026#39;随机循环 preload: \u0026#39;auto\u0026#39;, //预加载，可选值: \u0026#39;none\u0026#39;, \u0026#39;metadata\u0026#39;, \u0026#39;auto\u0026#39; volume: 0.7, //默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 mutex: true, //互斥，阻止多个播放器同时播放，当前播放器播放时暂停其他播放器 listFolded: false, //列表默认折叠 listMaxHeight: 90, //列表最大高度 lrcType: 3, //歌词传递方式 2.3 解释一下音乐的信息 1 2 3 4 5 title： 歌曲名称 author： 歌手 url：　歌曲外联地址 pic：　歌曲外联封面 lrc：　歌词 3 获取歌曲外联封面 打开《音乐外链网址mp3生成》，输入id获取外联\n4. 参考链接 https://www.cnblogs.com/Owen-ET/p/16518266.html ","pubDate":"2022-05-21","title":"cn博客添加音乐组件"},{"link":"https://hujian.xyz/posts/naivcat%E5%AE%89%E8%A3%85/","plain":"注册码： NAVH-WK6A-DMVK-DKW3\n","pubDate":"2022-05-19","title":"navicat 15注册码"},{"link":"https://hujian.xyz/posts/port-forward/","plain":"ssh端口转发(ssh port-forward) SSH 除了登录服务器，还有一大用途，就是作为加密通信的中介，充当两台服务器之间的通信加密跳板，使得原本不加密的通信变成加密通信。这个功能称为端口转发（port forwarding），又称 SSH 隧道（tunnel）。 端口转发有两个主要作用：\n将不加密的数据放在 SSH 安全连接里面传输，使得原本不安全的网络服务增加了安全性，比如通过端口转发访问 Telnet、FTP 等明文服务，数据传输就都会加密。\n作为数据通信的加密跳板，绕过网络防火墙。\n端口转发有三种使用方法：本地转发，远程转发，动态转发。 因为常用到了前两种转发，这里只介绍前两种转发。\n1. 本地转发 本地转发(local forwarding)指的是，将目标服务器的端口(target-host:target-port) 转发跳板机(tunnel-host) 映射到本地端口(local-port); 然后访问本地的端口(local-port)就可以通过跳板机(tunnel-host)转发到目标服务器的端口(target-host:target-port);\nsh -L local-port:target-host:target-port tunnel-host 示例：\n转发redis到本地16379 ssh -L 16379:127.0.0.1:6379 dev.hujian.xyz -N 2. 远程转发 远程转发指的是在远程 SSH 服务器建立的转发规则。 它跟本地转发正好反过来。建立本地计算机到远程计算机的 SSH 隧道以后，本地转发是通过本地计算机访问远程计算机，而远程转发则是通过远程计算机访问本地计算机。它的命令格式如下。\nssh -R remote-port:target-host:target-port -N remotehost\n示例：\n远程计算机通过curl http://my.public.server:8080 访问本地的80 web服务 ssh -R 8080:localhost:80 -N my.public.server 3. k8s端口本地转发： redis端口转发示例：\nkubectl port-forward service/redis -n devops-test 26379:6379 4 参考连接： ssh 端口转发 An Illustrated Guide to SSH Tunnels kubernetes port-forward ","pubDate":"2022-05-10","title":"基于ssh隧道转发端口"},{"link":"https://hujian.xyz/posts/%E7%94%9F%E6%88%90https%E8%AF%81%E4%B9%A6/","plain":"生成HTTPS证书 1. 使用loge命令的方式生成HTTPS证书 参数说明：\n*.domain.com 替换为你的域名，支持所有子域名 \u0026ndash; dns 是指域名在哪个云厂商，支持的云厂商有alidns/cloudflare aws;详细参考github官方文档 CLOUDFLARE_EMAIL=\u0026#34;xx@gmail.com\u0026#34; \\\rCLOUDFLARE_API_KEY=\u0026#34;xxx\u0026#34; \\\rlego --email \u0026#34;xx@gmail.com\u0026#34; --dns cloudflare --domains \u0026#34;*.domain.com\u0026#34; run 2 使用certbot的方式生成HTTPS证书 xx.domain.com 替换为你指定的子域名，只支持单个子域名\nsudo certbot certonly --agree-tos --email xx@gmail.com --webroot -w /var/lib/letsencrypt/ -d xx.domain.com 3.检查HTTPS证书是否生效 cfssl-certinfo -domain xx.domain.com:443 4 参考文档： 使用certbot的方式生成HTTPS证书 使用lego手动生成tls证书参数文档 ","pubDate":"2022-03-21","title":"生成HTTPS证书"},{"link":"https://hujian.xyz/posts/seo%E4%BC%98%E5%8C%96/","plain":"1. seo网站搜索优化 搜索排行问题，主要是两方面优化方向：\n第一是外链引用 第二是让搜索引擎的爬虫能收录/分析页面中的文本 技术相关的是第二，针对技术上的解决方案:\n分析是否指定的浏览器才能展示结果，比如google游览器能正常访问网页，IE游览器访问 404，这样会影响搜索引擎的爬虫对真实内容的爬取，搜索引擎收录到这样的页面，一个相关的词都没有，搜索索引是没法建立的。解决方案是去掉这个判断逻辑。\n网站是动态内容，且没有提供sitemap文件。这样的话，意味着即便没有第一个问题，搜索引擎也只会收录到了根页面，其它主页面、各个产品页，是不可能被收录到的，关键词索引也无从建立。解决方案是通过工具自动/手动生成一个根目录sitemap文件，和前端页面一起部署。\n在网关title加上name为keywords和description 以及对应的content描述\n示例： 1 \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;LoRaWAN,LoRaWAN module,LoRaWAN gateway,LoRaWAN 解决方案\u0026#34;\u0026gt;\u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;....\u0026#34;\u0026gt; 通过Google/百度站点管理工具分析数据，通过此分析 官网相关的关键列表、搜索率、点击率等指标在一定时间范围内的变化，一个是看之前是什么状态，另外一个 要看解决了以上3个问题后，后面有没有得到改进。 2. 解决方案 目的：\n提交seo收录，sitemap站点地图,将robots.t文件和sitemap.xml文件放到网站根目录下，示例文件如下: 蜘蛛访问站点权限 robots 站点sitemap地图 sitemap 通过站长工具分析网关排名以及关键字索引 百度站长 google站长 通过模拟器分析网站关键字收录情况 蜘蛛模拟-Screaming Frog SEO Spider 3 参考 seo优化 ","pubDate":"2022-03-10","title":"seo网站搜索优化"},{"link":"https://hujian.xyz/posts/ssh%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9/","plain":"1. ssh密钥对 ssh key的类型有四种，分别是dsa、rsa、 ecdsa、ed25519。 根据数学特性，这四种类型又可以分为两大类，dsa/rsa是一类，ecdsa/ed25519是一类，后者算法更先进。 dsa因为安全问题，已不再使用了。 ecdsa因为政治原因和技术原因，也不推荐使用。 rsa是目前兼容性最好的，应用最广泛的key类型，在用ssh-keygen工具生成key的时候，默认使用的也是这种类型。不过在生成key时，如果指定的key size太小的话，也是有安全问题的，推荐key size是3072或更大。 ed25519是目前最安全、加解密速度最快的key类型，由于其数学特性，它的key的长度比rsa小很多，优先推荐使用。它目前唯一的问题就是兼容性，即在旧版本的ssh工具集中可能无法使用。不过据我目前测试，还没有发现此类问题 2. ed25519 生成密钥对 ssh-keygen -t ed25519 -C \u0026quot;your_email@example.com\u0026quot; -f ed25519file\n参数解释： -t： 指定使用的数字签名算法； -C: 注释，随便填； -f: 指定文件输出位置，可选默认为 ~/.ssh/ 3. 验证ssh密钥对 添加公钥：\nGitee公钥管理页面 GitHub公钥管理页面 验证命令，前提条件: 已经添加了公钥\n1 2 ssh -T git@github.com # github ssh -T git@gitee.com # gitee 4. 总结 优先选择ed25519，否则选择rsa。 RSA算法通过使用不同的密钥进行加密和解密，实现了信息的保密性和完整性。它在实际应用中被广泛使用，但需要注意选择足够大的密钥长度以确保安全性。在安全性方面，RSA算法主要受到大整数分解问题的影响，随着量子计算技术的进步，RSA算法的安全性可能会受到威胁，因此一些新的算法如Ed25519等逐渐被引入以满足未来的安全需求。\n5. RSA算法 RSA是一种非对称加密算法，由Ron Rivest、Adi Shamir和Leonard Adleman于1977年共同提出。它在加密和数字签名领域广泛使用，并且具有较高的安全性。RSA算法基于大整数分解的困难性，其安全性依赖于对两个大素数的质因数分解。下面是RSA算法的基本步骤：\n密钥生成： 选择两个大素数p和q。这两个素数要足够大，以保证分解N = pq非常困难。 计算N = pq，N将成为公钥的一部分，也被称为\u0026quot;模数\u0026quot;。 计算Φ(N) = (p-1)(q-1)，Φ(N)也被称为\u0026quot;欧拉函数\u0026quot;。 选择一个整数e，使得1 \u0026lt; e \u0026lt; Φ(N)且e与Φ(N)互质。e将成为公钥的一部分，被称为\u0026quot;公钥指数\u0026quot;。 计算e的乘法逆元d，使得d * e ≡ 1 (mod Φ(N))。d将成为私钥的一部分，被称为\u0026quot;私钥指数\u0026quot;。 加密： 要加密的明文消息m被转换为一个整数M，使得0 ≤ M \u0026lt; N。 加密者使用公钥 (N, e) 对整数M进行加密，计算密文C = M^e mod N。C就是加密后的密文。 解密： 接收者使用私钥 (N, d) 对密文C进行解密，计算明文消息 M = C^d mod N。M就是解密后的原始消息。 数字签名： 要对消息进行数字签名，签名者使用私钥 (N, d) 对消息进行签名。 签名者对消息m计算消息摘要，通常使用哈希函数，得到一个固定长度的摘要。 签名者使用私钥对摘要进行加密，得到签名S = Hash(m)^d mod N。 签名S就是数字签名，它可以被任何拥有公钥的人验证。 验证数字签名： 接收者获得签名S和公钥 (N, e)。 接收者对签名S使用公钥进行解密，得到签名摘要S^e mod N。 接收者对收到的消息m计算消息摘要，得到 Hash(m)。 如果签名摘要与计算的消息摘要相等，则认为签名是有效的，否则认为签名是无效的。 6. Ed25519算法 Ed25519是一种基于椭圆曲线密码学的非对称加密算法，用于数字签名。它基于Curve25519椭圆曲线和Edwards曲线形式，由Daniel J. Bernstein等人在2011年提出。Ed25519算法具有高性能和较短的密钥长度，同时对抗量子计算攻击具有较好的安全性。 下面是Ed25519算法的基本步骤：\n密钥生成： 选择一个256位的随机数作为私钥，称为\u0026quot;私钥种子\u0026quot;。 使用哈希函数（通常是SHA-512）对私钥种子进行处理，生成一个256位的私钥。 根据私钥计算相应的公钥。公钥可以通过执行一系列计算得到，包括点倍乘等操作。 2. 签名：\n要对消息进行签名，签名者使用私钥对消息进行哈希处理，通常使用SHA-512。 使用私钥对哈希值进行签名，通过执行一系列椭圆曲线操作来生成签名。 签名结果包含两个部分：32字节的R（签名的一部分）和32字节的S（签名的另一部分）。\n3.验证签名：\n接收者获取签名、公钥和原始消息。 使用哈希函数对原始消息进行处理，得到哈希值。 执行一系列椭圆曲线操作，使用公钥和签名来验证签名的有效性。 验证的结果是签名的有效性，可以确定消息的完整性和认证性。\nEd25519算法具有以下特点和优势： 高性能：Ed25519算法具有较快的签名速度和验证速度，适合在资源有限的环境中使用。 较短的密钥长度：Ed25519算法使用的密钥长度为256位，较短，减少了密钥管理的复杂性和存储需求。 抗量子计算攻击：Ed25519算法基于椭圆曲线密码学，相对于RSA等算法，在抵抗量子计算攻击方面更具优势。 简化的操作步骤：相比其他椭圆曲线算法(比如：ECDSA非对称算法)，Ed25519算法的操作步骤相对简化，提高了实现的安全性和可靠性。 安全性和可靠性：Ed25519算法经过广泛的安全审查和分析，被认为是一种安全可靠的加密算法。 综上所述，Ed25519算法是一种高性能、安全可靠且抗量子计算攻击的非对称加密算法，特别适用于数字签名场景。它的简洁性和高效性使其在实际应用中得到了广泛的采用。\n7. 参考连接 无名之辈 ssh 密钥对解释 ","pubDate":"2021-03-10","title":"ssh密钥对"},{"link":"https://hujian.xyz/posts/docker%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/","plain":"1.指定docker数据存储路径 1.1 环境： centos 7.9 Docker version 20.10.10, build b485636 1.2 设置docker工作目录： 查看docker配置文件root目录 [root@localhost ~]# cat /usr/lib/systemd/system/docker.service |grep \u0026#34;ExecStart\u0026#34;\rExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock 停止正在运行的docker镜像以及docker服务 查看docker实际的数据存储目录，移动源(旧)数据到新的docker root目录： 1 2 3 docker info |grep \u0026#34;Docker Root Dir\u0026#34; systemctl stop docker.socket mv /var/lib/docker /data docker指定data存储位置 配置注意事项 1：以下内容中 \u0026ndash;insecure-registry=192.168.0.15 此处改为你自己服务器ip。 或者不填写也可以; 2：以下内容中 -graph /data/docker 是指定docker root路径 3：Docker version 23.0.0, build e92dd87 docker 23.0.0版本指定docker root路径 \u0026ndash;data-root /data/docker 20.10.10 配置root路径 \u0026ndash;graph：\nvi /usr/lib/systemd/system/docker.service\rExecStart=/usr/bin/dockerd --graph /data/docker -H fd:// --containerd=/run/containerd/containerd.sock 23.0.0 以及以后的版本配置root路径 -data-root：\nvi /usr/lib/systemd/system/docker.service\rExecStart=/usr/bin/dockerd --data-root /data/docker -H fd:// --containerd=/run/containerd/containerd.sock 重启docker 生效 systemctl daemon-reload systemctl restart docker 2. 常用命令 2.1 查看容器网络映射端口 docker network inspect bridge\n2.2 进入容器 docker exec -it 63021ad8716d /bin/bash\n2.3 查看使用状态 docker stats\n2.4 查看Docker正在运行的容器是通过什么命名启动的 docker ps -a --no-trunc docker history minio/minio:latest --format \u0026quot;table {{.ID}}{{.CreatedBy}}\u0026quot; --no-trunc 2.5 查看docker 占用的空间 docker system df docker system df -v\n2.6 清理docker磁盘空间 docker system prune -a sudo apt-get clean\n2.7 批量删除镜像 2.7.1 批量删除无tag标签镜像\ndocker images|grep none|awk '{print $3}'|xargs docker rmi 2.7.2 批量删除已经退出的容器：\ndocker ps -a |grep Exited|awk '{print $1}'|xargs docker rm 2.7.3 强制删除所有的镜像\ndocker rmi -f $(docker images -qa) 2.8 查看日志 2.8.1 查看指定时间日志: docker logs -t --since=\u0026#34;2022-11-16\u0026#34; d1826d2bb544\rdocker logs minio --since=\u0026#34;2022-11-16\u0026#34; 2\u0026gt;\u0026amp;1 --until \u0026#34;2022-11-16T18:30\u0026#34; docker logs minio --since=\u0026#34;2022-11-16\u0026#34; 2\u0026gt;\u0026amp;1 --until \u0026#34;2022-11-16T18:30\u0026#34; |grep \u0026#34;error\u0026#34;\rdocker logs minio --since=\u0026#34;2022-11-16\u0026#34; 2\u0026gt;\u0026amp;1 --until \u0026#34;2022-11-16T18:30\u0026#34; |grep \u0026#34;error\u0026#34; -C 10 2.8.2 查看最后10条日志 docker logs -f --tail 10 f7255fec27e5\rdocker logs -f --tail 10 f7255fec27e5 2\u0026gt;\u0026amp;1 |grep \u0026#34;error\u0026#34;\rdocker logs -f --tail 10 f7255fec27e5 2\u0026gt;\u0026amp;1 |grep \u0026#34;error\u0026#34; -C 10 2.9 对已经启动的容器设置开机自启动： docker update \u0026ndash;restart=always 你的镜像名称\n2.10 docker 镜像内复制文件到宿主机上 docker cp iotsquare:/etc/iotsquare/iotsquare.toml . 2.11 宿主机上文件复制到 docker 镜像内 docker cp iotsquare.toml iotsquare:/home\n2.10 docker 保存镜像 docker save -o test.tar registry.cn-shenzhen.aliyuncs.com/{{name}}/{object}:{version}\n2.11 docker 加载镜像 docker load --input test.tar\n2.12. 创建和运行容器： docker run：运行一个新的容器。 docker start：启动一个已停止的容器。 docker stop：停止一个运行中的容器。 docker restart：重启一个容器。 docker exec：在正在运行的容器中执行命令。 2.13 管理容器： docker ps：列出正在运行的容器。 docker ps -a：列出所有容器，包括已停止的。 docker rm：删除一个或多个容器。 2.14. 管理镜像： docker images：列出本地镜像。 docker pull：从 Docker Hub 下载镜像。 docker build：构建一个镜像。 docker rmi：删除一个或多个本地镜像。 2.15. 容器和主机之间的拷贝： docker cp：在容器和主机之间拷贝文件。 2.16. 管理网络： docker network ls：列出所有网络。 docker network create：创建一个新的网络。 docker network rm：删除一个网络。 2.17. 管理数据卷： docker volume ls：列出所有数据卷。 docker volume create：创建一个新的数据卷。 docker volume rm：删除一个数据卷。 2.18. 查找容器和镜像： docker search：在 Docker Hub 上搜索镜像。 2.19. 暂停和恢复容器： docker pause：暂停一个运行中的容器。 docker unpause：恢复一个暂停的容器。 3. docker镜像库 To use the access token from your Docker CLI client:\nRun docker login -u {name}\nAt the password prompt, enter the personal access token. xx-xx-xx-xx\n4. 以普通用户运行docker容器 4.1 root账户下添加用户： passwd test 4.2 修改用户可以使用root权限 1 2 3 4 sudo vi /etc/sudoers # 添加行 root ALL=(ALL) ALL test ALL=(ALL) ALL 4.3 将用户加入docker用户组： 1 2 3 4 su test sudo groupadd docker sudogpasswd -a test docker newgrp docker 5. docker-compose 安装: curl -L https://github.com/docker/compose/releases/download/1.24.0-rc3/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\rchmod +x /usr/local/bin/docker-compose 6. docker 配置代理 1. 修改配置 $ systemctl edit docker.service\n[Service]\rEnvironment=\u0026#34;HTTP_PROXY=http://192.168.159.132:8123\u0026#34;\rEnvironment=\u0026#34;HTTPS_PROXY=http://192.168.159.132:8123\u0026#34;\rEnvironment=\u0026#34;NO_PROXY=localhost,127.0.0.1\u0026#34; 2. 显示配置结果： systemctl show --property Environment docker.service 3. 重新启动服务 systemctl restart docker.service\n参考链接 Docker基础技术-陈浩 Docker 中文指南 ","pubDate":"2021-03-02","title":"docker基础应用"}];
    var search_theEnd = "到底了";
    var search_nothing = "什么也没找到";
    var search_found = "找到";
    var search_result = "条结果";
    var search_results = "条结果";
    var enable_mermaid =  null 
</script>





        
    </body>
</html>

